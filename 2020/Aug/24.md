# August 24th 2020

I learned about Jib - https://github.com/GoogleContainerTools/jib from our
company chat

https://cloudplatform.googleblog.com/2018/07/introducing-jib-build-java-docker-images-better.html

It can build images without docker and push it to image registry too!!
And there are gradle plugins for it!

Currently I need some docker registry to push this thing to. I was thinking of
running the registry -

https://hub.docker.com/_/registry
https://github.com/docker/distribution
https://github.com/docker/distribution-library-image (docker image / docker file source code)

Instructions for deployment - https://github.com/docker/docker.github.io/blob/master/registry/deploying.md

But it needs docker to run. I mean, I don't want to run docker, to make sure
that Jib does it all without docker. Just to make sure. I don't know how else
to check - maybe one way could be, see if docker containers are running or
something while building as I have heard docker uses containers for the build
but I don't know if it will be visible to users. Hmm. No docker running is
very easy I guess

If not docker registry software...

I could just run Harbor I think

https://goharbor.io/ 

https://goharbor.io/docs/2.0.0/install-config/

There's even a demo server here - https://demo.goharbor.io/
https://goharbor.io/docs/2.0.0/install-config/demo-server/

Given I just want to test the whole thing, and if I use dummy code, I could
just test with Docker Hub, the only problem is - when it comes to private
source code and private image, I need some secure place, and my local is the
best!

Again, it needs docker and it has too many components
https://goharbor.io/docs/2.0.0/install-config/#harbor-components

---

I'm just going to run `registry`

I got the code 
https://github.com/docker/distribution

And ran

```bash
$ make
...
$ cd bin
$ ls registry
registry
$ ./registry -h
`registry`

Usage:
  registry [flags]
  registry [command]

Available Commands:
  garbage-collect `garbage-collect` deletes layers not referenced by any manifests
  help            Help about any command
  serve           `serve` stores and distributes Docker images

Flags:
  -h, --help      help for registry
  -v, --version   show the version and exit

Use "registry [command] --help" for more information about a command.
$ ./registry serve -h
`serve` stores and distributes Docker images.

Usage:
  registry serve <config> [flags]

Flags:
  -h, --help   help for serve
```

Looking at

https://github.com/docker/distribution-library-image/blob/master/arm64/
https://github.com/docker/distribution-library-image/blob/master/arm64/Dockerfile
https://github.com/docker/distribution-library-image/blob/master/arm64/docker-entrypoint.sh
https://github.com/docker/distribution-library-image/blob/master/arm64/config-example.yml

```bash
$ vi config.yml
$ cat config.yml
version: 0.1
log:
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: /var/lib/registry
http:
  addr: :5000
  headers:
    X-Content-Type-Options: [nosniff]
health:
  storagedriver:
    enabled: true
    interval: 10s
    threshold: 3

```

```bash
$ ./registry serve config.yml
WARN[0000] No HTTP secret provided - generated random secret. This may cause problems with uploads if multiple registries are behind a load-balancer. To provide a shared secret, fill in http.secret in the configuration file or set the REGISTRY_HTTP_SECRET environment variable.  go.version=go1.15 instance.id=8f6aff2f-d808-4a00-bf9a-85803f24789a service=registry version=v2.7.0-153-g0316f34b
INFO[0000] redis not configured                          go.version=go1.15 instance.id=8f6aff2f-d808-4a00-bf9a-85803f24789a service=registry version=v2.7.0-153-g0316f34b
INFO[0000] Starting upload purge in 52m0s                go.version=go1.15 instance.id=8f6aff2f-d808-4a00-bf9a-85803f24789a service=registry version=v2.7.0-153-g0316f34b
INFO[0000] using inmemory blob descriptor cache          go.version=go1.15 instance.id=8f6aff2f-d808-4a00-bf9a-85803f24789a service=registry version=v2.7.0-153-g0316f34b
INFO[0000] listening on [::]:5000                        go.version=go1.15 instance.id=8f6aff2f-d808-4a00-bf9a-85803f24789a service=registry version=v2.7.0-153-g0316f34b
```

Yay! :D It works! :D

Now in the helloworld example in JIB, it didn't workout as I think I have a
different Java version and it is based on Java 8. Hmm

```bash
$ ./gradlew tasks

FAILURE: Build failed with an exception.

* What went wrong:
Could not create an instance of type org.gradle.initialization.DefaultSettings_Decorated.
> Could not initialize class org.codehaus.groovy.runtime.InvokerHelper

* Try:
Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Exception is:
org.gradle.api.reflect.ObjectInstantiationException: Could not create an instance of type org.gradle.initialization.DefaultSettings_Decorated.
	at org.gradle.internal.reflect.DirectInstantiator.newInstance(DirectInstantiator.java:53)
	at org.gradle.api.internal.ClassGeneratorBackedInstantiator.newInstance(ClassGeneratorBackedInstantiator.java:36)
	at org.gradle.initialization.SettingsFactory.createSettings(SettingsFactory.java:52)
	at org.gradle.initialization.ScriptEvaluatingSettingsProcessor.process(ScriptEvaluatingSettingsProcessor.java:56)
	at org.gradle.initialization.PropertiesLoadingSettingsProcessor.process(PropertiesLoadingSettingsProcessor.java:37)
	at org.gradle.initialization.SettingsEvaluatedCallbackFiringSettingsProcessor.process(SettingsEvaluatedCallbackFiringSettingsProcessor.java:34)
	at org.gradle.initialization.RootBuildCacheControllerSettingsProcessor.process(RootBuildCacheControllerSettingsProcessor.java:36)
	at org.gradle.initialization.BuildOperationSettingsProcessor$2.call(BuildOperationSettingsProcessor.java:48)
	at org.gradle.initialization.BuildOperationSettingsProcessor$2.call(BuildOperationSettingsProcessor.java:45)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:315)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:305)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:175)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:101)
	at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
	at org.gradle.initialization.BuildOperationSettingsProcessor.process(BuildOperationSettingsProcessor.java:45)
	at org.gradle.initialization.DefaultSettingsLoader.findSettingsAndLoadIfAppropriate(DefaultSettingsLoader.java:104)
	at org.gradle.initialization.DefaultSettingsLoader.findAndLoadSettings(DefaultSettingsLoader.java:45)
	at org.gradle.initialization.SettingsAttachingSettingsLoader.findAndLoadSettings(SettingsAttachingSettingsLoader.java:35)
	at org.gradle.internal.composite.CommandLineIncludedBuildSettingsLoader.findAndLoadSettings(CommandLineIncludedBuildSettingsLoader.java:34)
	at org.gradle.internal.composite.ChildBuildRegisteringSettingsLoader.findAndLoadSettings(ChildBuildRegisteringSettingsLoader.java:47)
	at org.gradle.internal.composite.CompositeBuildSettingsLoader.findAndLoadSettings(CompositeBuildSettingsLoader.java:35)
	at org.gradle.initialization.DefaultGradleLauncher$LoadBuild.run(DefaultGradleLauncher.java:277)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:301)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:293)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:175)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:91)
	at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)
	at org.gradle.initialization.DefaultGradleLauncher.loadSettings(DefaultGradleLauncher.java:202)
	at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:147)
	at org.gradle.initialization.DefaultGradleLauncher.executeTasks(DefaultGradleLauncher.java:134)
	at org.gradle.internal.invocation.GradleBuildController$1.execute(GradleBuildController.java:58)
	at org.gradle.internal.invocation.GradleBuildController$1.execute(GradleBuildController.java:55)
	at org.gradle.internal.invocation.GradleBuildController$3.create(GradleBuildController.java:82)
	at org.gradle.internal.invocation.GradleBuildController$3.create(GradleBuildController.java:75)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:183)
	at org.gradle.internal.work.StopShieldingWorkerLeaseService.withLocks(StopShieldingWorkerLeaseService.java:40)
	at org.gradle.internal.invocation.GradleBuildController.doBuild(GradleBuildController.java:75)
	at org.gradle.internal.invocation.GradleBuildController.run(GradleBuildController.java:55)
	at org.gradle.tooling.internal.provider.ExecuteBuildActionRunner.run(ExecuteBuildActionRunner.java:31)
	at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35)
	at org.gradle.launcher.exec.BuildOutcomeReportingBuildActionRunner.run(BuildOutcomeReportingBuildActionRunner.java:58)
	at org.gradle.tooling.internal.provider.ValidatingBuildActionRunner.run(ValidatingBuildActionRunner.java:32)
	at org.gradle.launcher.exec.BuildCompletionNotifyingBuildActionRunner.run(BuildCompletionNotifyingBuildActionRunner.java:39)
	at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner$3.call(RunAsBuildOperationBuildActionRunner.java:49)
	at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner$3.call(RunAsBuildOperationBuildActionRunner.java:44)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:315)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:305)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:175)
	at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:101)
	at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
	at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner.run(RunAsBuildOperationBuildActionRunner.java:44)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter$1.transform(InProcessBuildActionExecuter.java:49)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter$1.transform(InProcessBuildActionExecuter.java:46)
	at org.gradle.composite.internal.DefaultRootBuildState.run(DefaultRootBuildState.java:78)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:46)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:31)
	at org.gradle.launcher.exec.BuildTreeScopeBuildActionExecuter.execute(BuildTreeScopeBuildActionExecuter.java:42)
	at org.gradle.launcher.exec.BuildTreeScopeBuildActionExecuter.execute(BuildTreeScopeBuildActionExecuter.java:28)
	at org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:78)
	at org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:52)
	at org.gradle.tooling.internal.provider.SubscribableBuildActionExecuter.execute(SubscribableBuildActionExecuter.java:59)
	at org.gradle.tooling.internal.provider.SubscribableBuildActionExecuter.execute(SubscribableBuildActionExecuter.java:36)
	at org.gradle.tooling.internal.provider.SessionScopeBuildActionExecuter.execute(SessionScopeBuildActionExecuter.java:68)
	at org.gradle.tooling.internal.provider.SessionScopeBuildActionExecuter.execute(SessionScopeBuildActionExecuter.java:38)
	at org.gradle.tooling.internal.provider.GradleThreadBuildActionExecuter.execute(GradleThreadBuildActionExecuter.java:37)
	at org.gradle.tooling.internal.provider.GradleThreadBuildActionExecuter.execute(GradleThreadBuildActionExecuter.java:26)
	at org.gradle.tooling.internal.provider.ParallelismConfigurationBuildActionExecuter.execute(ParallelismConfigurationBuildActionExecuter.java:43)
	at org.gradle.tooling.internal.provider.ParallelismConfigurationBuildActionExecuter.execute(ParallelismConfigurationBuildActionExecuter.java:29)
	at org.gradle.tooling.internal.provider.StartParamsValidatingActionExecuter.execute(StartParamsValidatingActionExecuter.java:60)
	at org.gradle.tooling.internal.provider.StartParamsValidatingActionExecuter.execute(StartParamsValidatingActionExecuter.java:32)
	at org.gradle.tooling.internal.provider.SessionFailureReportingActionExecuter.execute(SessionFailureReportingActionExecuter.java:55)
	at org.gradle.tooling.internal.provider.SessionFailureReportingActionExecuter.execute(SessionFailureReportingActionExecuter.java:41)
	at org.gradle.tooling.internal.provider.SetupLoggingActionExecuter.execute(SetupLoggingActionExecuter.java:48)
	at org.gradle.tooling.internal.provider.SetupLoggingActionExecuter.execute(SetupLoggingActionExecuter.java:32)
	at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:67)
	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:37)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:26)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.RequestStopIfSingleUsedDaemon.execute(RequestStopIfSingleUsedDaemon.java:34)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:74)
	at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:72)
	at org.gradle.util.Swapper.swap(Swapper.java:38)
	at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:72)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.LogAndCheckHealth.execute(LogAndCheckHealth.java:55)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:62)
	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:81)
	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36)
	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:104)
	at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:50)
	at org.gradle.launcher.daemon.server.DaemonStateCoordinator$1.run(DaemonStateCoordinator.java:295)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
Caused by: java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.runtime.InvokerHelper
	at org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension.<init>(DefaultExtraPropertiesExtension.java:29)
	at org.gradle.api.internal.plugins.DefaultConvention.<init>(DefaultConvention.java:47)
	at org.gradle.api.internal.ExtensibleDynamicObject.<init>(ExtensibleDynamicObject.java:58)
	at org.gradle.initialization.DefaultSettings.<init>(DefaultSettings.java:93)
	at org.gradle.initialization.DefaultSettings_Decorated.<init>(Unknown Source)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at org.gradle.internal.reflect.DirectInstantiator.newInstance(DirectInstantiator.java:51)
	... 100 more


* Get more help at https://help.gradle.org

BUILD FAILED in 0s
```

I'm gonna try changing it in the `build.gradle` in `sourceCompatibility` and
`targetCompatibility`, but the values `1.14` or `14` didn't workout.

---

I'm just going to use Jib in my private project

https://plugins.gradle.org/plugin/com.google.cloud.tools.jib

Under plugins

```groovy
id 'com.google.cloud.tools.jib' version '2.5.0'
```

```
jib.to.image = 'localhost:5000/image-built-with-jib:0.1.0'
```

```bash
$ ./gradlew tasks
```

It shows Jib related tasks

```
Jib tasks
---------
jib - Builds a container image to a registry.
jibBuildTar - Builds a container image to a tarball.
jibDockerBuild - Builds a container image to a Docker daemon.
```

I think I could have just used the tarball one, since I didn't want to run a
docker daemon and I didn't want to push to a registry really. RIGHT. Hmm.
Anyways.

```bash
$ ./gradlew jib
> Task :jib FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':jib'.
> Your project is using Java 14 but the base image is for Java 11, perhaps you should configure a Java 14-compatible base image using the 'jib.from.image' parameter, or set targetCompatibility = 11 or below in your build configuration

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.6/userguide/command_line_interface.html#sec:command_line_warnings

BUILD FAILED in 6s
3 actionable tasks: 2 executed, 1 up-to-date
```

So, it's using Java 11 as base image. Hmm.

I tried this

```groovy
jib.from.image = 'adoptopenjdk:14-jdk-hotspot'
```

And it didn't workout

```bash
$ ./gradlew jib
> Task :compileJava UP-TO-DATE
> Task :processResources UP-TO-DATE
> Task :classes UP-TO-DATE

> Task :jib

Containerizing application to [36mlocalhost:5000/image-built-with-jib:0.1.0[0m...
Base image 'adoptopenjdk:14-jdk-hotspot' does not use a specific image digest - build may not be reproducible
[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> building image to registry[0m
[1m[0m
[4A[0J
[1A[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m[0m
[4A[0J
[1A[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m> launching application layer builders[0m
[1m[0m
[6A[0J
[1A[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m> building dependencies layer[0m
[1m[0m
[6A[0J
[1A[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m> building dependencies layer[0m
[1m> building resources layer[0m
[1m[0m
[7A[0J
[1A[1mExecuting tasks:[0m
[1m[                              ] 0.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m> building dependencies layer[0m
[1m> building resources layer[0m
[1m> building classes layer[0m
[1m[0m
[8A[0J
[1A[1mExecuting tasks:[0m
[1m[=                             ] 3.3% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m> building dependencies layer[0m
[1m> building classes layer[0m
[1m[0m
[7A[0J
[1A[1mExecuting tasks:[0m
[1m[==                            ] 6.7% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[1mExecuting tasks:[0m
[1m[===                           ] 10.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1AUsing credentials from Docker config (/Users/karuppiahn/.docker/config.json) for localhost:5000/image-built-with-jib:0.1.0
[1mExecuting tasks:[0m
[1m[===                           ] 10.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[1mExecuting tasks:[0m
[1m[=====                         ] 15.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[31;1mI/O error for image [localhost:5000/image-built-with-jib]:[0m
[1mExecuting tasks:[0m
[1m[=====                         ] 15.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[31;1m    javax.net.ssl.SSLException[0m
[1mExecuting tasks:[0m
[1m[=====                         ] 15.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[31;1m    Unsupported or unrecognized SSL message[0m
[1mExecuting tasks:[0m
[1m[=====                         ] 15.0% complete[0m
[1m> authenticating push to localhost:5000[0m
[1m> pulling base image manifest[0m
[1m[0m
[5A[0J
[1A[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1AThe base image requires auth. Trying again for adoptopenjdk:14-jdk-hotspot...
[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1AThe credential helper (docker-credential-desktop) has nothing for server URL: registry-1.docker.io

Got output:

credentials not found in native keychain

[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1AUsing credentials from Docker config (/Users/karuppiahn/.docker/config.json) for adoptopenjdk:14-jdk-hotspot
[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1AThe base image reference is a manifest list, searching for architecture=amd64, os=linux
[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1AUsing base image with digest: sha256:fd2d3289b0c8e4b776ad82e4d5481f8888c927714210f3482a88c87d569637d1
[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1A[1mExecuting tasks:[0m
[1m[======                        ] 20.0% complete[0m
[1m> pull container configuration sha256:29d25d481...[0m
[1m[0m
[4A[0J
[1A[1mExecuting tasks:[0m
[1m[========                      ] 25.0% complete[0m
[1m> pulling base image manifest[0m
[1m[0m
[4A[0J
[1A[1mExecuting tasks:[0m
[1m[=========                     ] 30.0% complete[0m
[1m> building image to registry[0m
[1m[0m

> Task :jib FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':jib'.
> com.google.cloud.tools.jib.plugins.common.BuildStepsExecutionException: Build image failed, perhaps you should use a registry that supports HTTPS or set the configuration parameter 'allowInsecureRegistries'

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.6/userguide/command_line_interface.html#sec:command_line_warnings

BUILD FAILED in 9s
3 actionable tasks: 1 executed, 2 up-to-date
```

I also did some docker login in between

```bash
$ docker login localhost:5000
```

and gave `admin` and `admin` as username and password.

It's about HTTPS registries or I need to set some parameter. It's still using
my docker config at `/Users/karuppiahn/.docker/config.json`

Okay, I'm just gonna create a tar ball for now.

That worked! :D

```bash
$ ./gradlew jibBuildTar

> Task :jibBuildTar

Containerizing application to file at '/Users/karuppiahn/projects/service/build/jib-image.tar'...
Base image 'adoptopenjdk:14-jdk-hotspot' does not use a specific image digest - build may not be reproducible
The base image requires auth. Trying again for adoptopenjdk:14-jdk-hotspot...
The credential helper (docker-credential-desktop) has nothing for server URL: registry-1.docker.io

Got output:

credentials not found in native keychain

Using credentials from Docker config (/Users/karuppiahn/.docker/config.json) for adoptopenjdk:14-jdk-hotspot
The base image reference is a manifest list, searching for architecture=amd64, os=linux
Using base image with digest: sha256:fd2d3289b0c8e4b776ad82e4d5481f8888c927714210f3482a88c87d569637d1

Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, com.example.service]

Built image tarball at /Users/karuppiahn/projects/service/build/jib-image.tar
Executing tasks:
[==============================] 100.0% complete


Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.6/userguide/command_line_interface.html#sec:command_line_warnings

BUILD SUCCESSFUL in 49s
3 actionable tasks: 1 executed, 2 up-to-date
````

I tried with allow insecure registries parameter

```groovy
```

```bash
$ ./gradlew jib

> Task :jib

Containerizing application to localhost:5000/image-built-with-jib:0.1.0...
Base image 'adoptopenjdk:14-jdk-hotspot' does not use a specific image digest - build may not be reproducible
Using credentials from Docker config (/Users/karuppiahn/.docker/config.json) for localhost:5000/image-built-with-jib:0.1.0
Cannot verify server at https://localhost:5000/v2/. Attempting again with no TLS verification.
Failed to connect to https://localhost:5000/v2/ over HTTPS. Attempting again with HTTP.
The base image requires auth. Trying again for adoptopenjdk:14-jdk-hotspot...
The credential helper (docker-credential-desktop) has nothing for server URL: registry-1.docker.io

Got output:

credentials not found in native keychain

Using credentials from Docker config (/Users/karuppiahn/.docker/config.json) for adoptopenjdk:14-jdk-hotspot
The base image reference is a manifest list, searching for architecture=amd64, os=linux
Using base image with digest: sha256:fd2d3289b0c8e4b776ad82e4d5481f8888c927714210f3482a88c87d569637d1

Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, com.example.service]
Executing tasks:
[=====================         ] 68.3% complete
> pushing blob sha256:94e5ff4c0b1526abf77c23665...
> pushing blob sha256:70b59d0ba1afa968cb203531f...

> Task :jib FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':jib'.
> com.google.cloud.tools.jib.plugins.common.BuildStepsExecutionException: 500 Internal Server Error
  {"errors":[{"code":"UNKNOWN","message":"unknown error","detail":{"DriverName":"filesystem","Enclosed":{"Op":"mkdir","Path":"/var/lib/registry","Err":13}}}]}


* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.6/userguide/command_line_interface.html#sec:command_line_warnings

BUILD FAILED in 10s
3 actionable tasks: 1 executed, 2 up-to-date
```

There was a big error in my registry service about permission issues around
creating or accessing directory at `/var/lib/registry`. 

https://github.com/docker/distribution-library-image/blob/master/arm64/Dockerfile#L11

I realized we need it. So I created a local directory and also changed the
config.yml to point to that directory

```bash
$ mkdir registry-fs
$ vi config.yml
$ cat config.yml
version: 0.1
log:
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: registry-fs
http:
  addr: :5000
  headers:
    X-Content-Type-Options: [nosniff]
health:
  storagedriver:
    enabled: true
    interval: 10s
    threshold: 3

$ ./registry serve config.yml
WARN[0000] No HTTP secret provided - generated random secret. This may cause problems with uploads if multiple registries are behind a load-balancer. To provide a shared secret, fill in http.secret in the configuration file or set the REGISTRY_HTTP_SECRET environment variable.  go.version=go1.15 instance.id=0ad7fc73-8d6c-43b6-9d69-d6e247160b42 service=registry version=v2.7.0-153-g0316f34b
INFO[0000] redis not configured                          go.version=go1.15 instance.id=0ad7fc73-8d6c-43b6-9d69-d6e247160b42 service=registry version=v2.7.0-153-g0316f34b
INFO[0000] Starting upload purge in 57m0s                go.version=go1.15 instance.id=0ad7fc73-8d6c-43b6-9d69-d6e247160b42 service=registry version=v2.7.0-153-g0316f34b
INFO[0000] using inmemory blob descriptor cache          go.version=go1.15 instance.id=0ad7fc73-8d6c-43b6-9d69-d6e247160b42 service=registry version=v2.7.0-153-g0316f34b
INFO[0000] listening on [::]:5000                        go.version=go1.15 instance.id=0ad7fc73-8d6c-43b6-9d69-d6e247160b42 service=registry version=v2.7.0-153-g0316f34b
```

There were some errors in the registry logs, and some success. For jib this
was the log

```bash
$ ./gradlew jib

> Task :jib

Containerizing application to localhost:5000/image-built-with-jib:0.1.0...
Base image 'adoptopenjdk:14-jdk-hotspot' does not use a specific image digest - build may not be reproducible
Using credentials from Docker config (/Users/karuppiahn/.docker/config.json) for localhost:5000/image-built-with-jib:0.1.0
Cannot verify server at https://localhost:5000/v2/. Attempting again with no TLS verification.
Failed to connect to https://localhost:5000/v2/ over HTTPS. Attempting again with HTTP.
The base image requires auth. Trying again for adoptopenjdk:14-jdk-hotspot...
The credential helper (docker-credential-desktop) has nothing for server URL: registry-1.docker.io

Got output:

credentials not found in native keychain

Using credentials from Docker config (/Users/karuppiahn/.docker/config.json) for adoptopenjdk:14-jdk-hotspot
The base image reference is a manifest list, searching for architecture=amd64, os=linux
Using base image with digest: sha256:fd2d3289b0c8e4b776ad82e4d5481f8888c927714210f3482a88c87d569637d1

Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, com.example.service]

Built and pushed image as localhost:5000/image-built-with-jib:0.1.0
Executing tasks:
[==============================] 100.0% complete


Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.6/userguide/command_line_interface.html#sec:command_line_warnings

BUILD SUCCESSFUL in 11s
3 actionable tasks: 1 executed, 2 up-to-date
```

And I also ran Docker daemon and tried pulling the image! :D Initially there
were issues as my local registry was an insecure one

In my docker daemon config (not `/Users/karuppiahn/.docker/config.json` which
seems like docker client CLI config), I added this

```json
"insecure-registries": [
    "host.docker.internal:5000"
]
```

By checking this -
https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file

There's more info here
https://docs.docker.com/engine/reference/commandline/dockerd/#insecure-registries

```bash
$ docker pull host.docker.internal:5000/image-built-with-jib:0.1.0
0.1.0: Pulling from image-built-with-jib
f08d8e2a3ba1: Already exists
3baa9cb2483b: Already exists
94e5ff4c0b15: Already exists
1860925334f9: Already exists
f9b7f96c83b9: Pull complete
0d7b9167e3a1: Pull complete
3aa589115e63: Pull complete
aca4a44527ce: Pull complete
ecf75a54c773: Pull complete
Digest: sha256:eaeafd1216b271276c6f92c2b09a0cf1bf04d397896585e060e538630b4bb102
Status: Downloaded newer image for host.docker.internal:5000/image-built-with-jib:0.1.0
host.docker.internal:5000/image-built-with-jib:0.1.0
```

```bash
$ docker images host.docker.internal:5000/image-built-with-jib
REPOSITORY                                       TAG                 IMAGE ID            CREATED             SIZE
host.docker.internal:5000/image-built-with-jib   0.1.0               70b59d0ba1af        50 years ago        489MB
```

```bash
$ docker run --rm -p 8080:8080 host.docker.internal:5000/image-built-with-jib:0.1.0

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.3.3.RELEASE)

2020-08-24 05:08:39.696  INFO 1 --- [           main] d.s.o.o.ServiceApplication          : Starting ServiceApplication on f8faad78a6be with PID 1 (/app/classes started by root in /)
2020-08-24 05:08:39.702  INFO 1 --- [           main] d.s.o.o.ServiceApplication          : No active profile set, falling back to default profiles: default
2020-08-24 05:08:41.552  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2020-08-24 05:08:41.567  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-08-24 05:08:41.569  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.37]
2020-08-24 05:08:41.688  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-08-24 05:08:41.688  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1833 ms
2020-08-24 05:08:42.545  INFO 1 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-08-24 05:08:43.619  INFO 1 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 2 endpoint(s) beneath base path '/actuator'
2020-08-24 05:08:43.696  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-08-24 05:08:43.746  INFO 1 --- [           main] d.s.o.o.ServiceApplication          : Started ServiceApplication in 4.65 seconds (JVM running for 5.123)
2020-08-24 05:08:49.040  INFO 1 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-08-24 05:08:49.041  INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-08-24 05:08:49.056  INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 15 ms
```

```bash
$ curl localhost:8080
{"timestamp":"2020-08-24T05:12:24.221+00:00","status":404,"error":"Not Found","message":"","path":"/"}
```

So it all worked out! :D

Docker load worked too, with tar

```bash
$ docker load -i build/jib-image.tar

Loaded image: localhost:5000/image-built-with-jib:0.1.0
```

```bash
$ docker images localhost:5000/image-built-with-jib
REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE
localhost:5000/image-built-with-jib   0.1.0               70b59d0ba1af        50 years ago        489MB
```

---

Helm Hub is going to close and Artifact Hub is going to be it's successort.

https://hub.helm.sh/
https://artifacthub.io/
https://github.com/artifacthub/hub

Apparently it scales better.

What I don't understand is, how come almost everyone is doing things from
scratch.

https://www.npmjs.com/ has done it, but I guess now it's all closed source

https://docs.npmjs.com/misc/registry

https://skimdb.npmjs.com/registry
https://github.com/npm/npm-registry-couchapp

Rust crates.io - https://github.com/rust-lang/crates.io crates.io has also
solved this problem

And tons of other languages and platforms which needed to users to publish and
distribute things, where the owner / owners of the things were there, 2FA for
security and then teams / organizations concept etc.

A lot of things are common, except for the fact that, the thing to be published
or distributed is different - in terms of structure etc and it's concepts may
vary.

In general it's a package registry or artifact registry. I think JFrog
Artifactory understood it very well - https://jfrog.com/artifactory/

They host a lot of artifacts for lot of languages and platforms or ecosystems.
Golang modules, Ruby Gems, Java jars, npm packages, Docker images, tar balls etc

ArtifactHub is actually under CNCF. Now, Harbor is under CNCF too!

https://goharbor.io/

It's also a Cloud Native repository. Hmm. WEIRD. I wonder how many reinventing
wheels will happen. Not sure.

I mean, looking at the issues in ArtifactHub, https://github.com/artifacthub/hub/issues ,
they have stuff like showing view count, notifications and what not

https://github.com/artifacthub/hub/issues/565

I don't know which other software has this, but it seems like some similar
features for almost anything. I have seen it in npmjs, but that's private, so
meh.

I think download count is also one more thing.

I'm guessing Harbor is more for private registry usage? And not for hosting it
for the public? And also does not have UI and stuff? I mean, maybe not too much?
I don't know. And it looks like it talks only about Docker images. Yeah, only
about Docker image registry, along with some cool features. Hmm

Artifact Hub doesn't seem to support Docker images. But it has support for
Helm charts, and stuff like OPA etc. I don't know much about them.
It's weird. I thought Helm charts would be distributed as docker images or OCI
images. It was as if - anything that can be distributed with OCI images will be
distributed with OCI images. Anyways. It's weird to have to store in one format
and then convert it into a usable format. But it's kind of like compressing
and extracting only. Or I think it maybe literally that, since Docker is kind
of like some tar ball I think. It can be saved as one and one can be loaded from
it too. Hmm

