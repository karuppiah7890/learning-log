
$ ls /Library/Developer/CommandLineTools/usr/bin/
2to3				llvm-nm
2to3-3.8			llvm-objdump
2to3-3.9			llvm-otool
DeRez				llvm-profdata
GetFileInfo			llvm-size
ResMerger			lorder
Rez				m4
SetFile				make
SplitForks			mig
ar				nm
as				nm-classic
asa				nmedit
bison				notarytool
bitcode_strip			objdump
c++				otool
c++filt				otool-classic
c89				pagestuff
c99				pip3
cc				pip3.8
clang				pip3.9
clang++				projectInfo
clangd				pydoc3
cmpdylib			pydoc3.8
codesign_allocate		pydoc3.9
codesign_allocate-p		python3
cpp				python3.8
crashlog			python3.9
ctags				ranlib
ctf_insert			resolveLinks
dsymutil			rpcgen
dwarfdump			segedit
dwarfdump-classic		size
dyldinfo			size-classic
easy_install-3.8		sourcekit-lsp
flex				stapler
flex++				strings
g++				strip
gatherheaderdoc			swift
gcc				swift-api-digester
gcov				swift-api-extract
git				swift-build
git-receive-pack		swift-demangle
git-shell			swift-frontend
git-upload-archive		swift-package
git-upload-pack			swift-package-collection
gm4				swift-package-registry
gnumake				swift-run
gperf				swift-stdlib-tool
hdxml2manxml			swift-symbolgraph-extract
headerdoc2html			swift-test
indent				swiftc
install_name_tool		tapi
ld				tapi-analyze
lex				unifdef
libtool				unifdefall
lipo				unwinddump
lldb				vtool
llvm-cov			xcindex-test
llvm-cxxfilt			xml2man
llvm-dwarfdump			yacc

$ xcrun 
Usage: xcrun [options] <tool name> ... arguments ...

Find and execute the named command line tool from the active developer
directory.

The active developer directory can be set using `xcode-select`, or via the
DEVELOPER_DIR environment variable. See the xcrun and xcode-select manual
pages for more information.

Options:
  -h, --help                  show this help message and exit
  --version                   show the xcrun version
  -v, --verbose               show verbose logging output
  --sdk <sdk name>            find the tool for the given SDK name
  --toolchain <name>          find the tool for the given toolchain
  -l, --log                   show commands to be executed (with --run)
  -f, --find                  only find and print the tool path
  -r, --run                   find and execute the tool (the default behavior)
  -n, --no-cache              do not use the lookup cache
  -k, --kill-cache            invalidate all existing cache entries
  --show-sdk-path             show selected SDK install path
  --show-sdk-version          show selected SDK version
  --show-sdk-build-version    show selected SDK build version
  --show-sdk-platform-path    show selected SDK platform path
  --show-sdk-platform-version show selected SDK platform version

$ make
cd src && /Library/Developer/CommandLineTools/usr/bin/make all
    CC Makefile.dep
rm -rf valkey-server valkey-sentinel valkey-cli valkey-benchmark valkey-check-rdb valkey-check-aof valkey-unit-tests libvalkey.a unit/*.o unit/*.d *.o *.gcda *.gcno *.gcov valkey.info lcov-html Makefile.dep *.so
rm -f threads_mngr.d adlist.d quicklist.d ae.d anet.d dict.d hashtable.d kvstore.d server.d sds.d zmalloc.d lzf_c.d lzf_d.d pqsort.d zipmap.d sha1.d ziplist.d release.d memory_prefetch.d io_threads.d networking.d util.d object.d db.d replication.d rdb.d t_string.d t_list.d t_set.d t_zset.d t_hash.d config.d aof.d pubsub.d multi.d debug.d sort.d intset.d syncio.d cluster.d cluster_legacy.d cluster_slot_stats.d crc16.d endianconv.d commandlog.d eval.d bio.d rio.d rand.d memtest.d syscheck.d crcspeed.d crccombine.d crc64.d bitops.d sentinel.d notify.d setproctitle.d blocked.d hyperloglog.d latency.d sparkline.d valkey-check-rdb.d valkey-check-aof.d geo.d lazyfree.d module.d evict.d expire.d geohash.d geohash_helper.d childinfo.d allocator_defrag.d defrag.d siphash.d rax.d t_stream.d listpack.d localtime.d lolwut.d lolwut5.d lolwut6.d acl.d tracking.d socket.d tls.d sha256.d timeout.d setcpuaffinity.d monotonic.d mt19937-64.d resp_parser.d call_reply.d script_lua.d script.d functions.d function_lua.d commands.d strl.d connection.d unix.d logreqres.d rdma.d scripting_engine.d anet.d adlist.d dict.d valkey-cli.d zmalloc.d release.d ae.d serverassert.d crcspeed.d crccombine.d crc64.d siphash.d crc16.d monotonic.d cli_common.d mt19937-64.d strl.d cli_commands.d ae.d anet.d valkey-benchmark.d adlist.d dict.d zmalloc.d serverassert.d release.d crcspeed.d crccombine.d crc64.d siphash.d crc16.d monotonic.d cli_common.d mt19937-64.d strl.d
(cd ../deps && /Library/Developer/CommandLineTools/usr/bin/make distclean)
(cd hiredis && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd linenoise && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd lua && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd jemalloc && [ -f Makefile ] && /Library/Developer/CommandLineTools/usr/bin/make distclean) > /dev/null || true
(cd hdr_histogram && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd fpconv && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd fast_float_c_interface && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(rm -f .make-*)
(cd modules && /Library/Developer/CommandLineTools/usr/bin/make clean)
rm -rf *.xo *.so
(cd ../tests/modules && /Library/Developer/CommandLineTools/usr/bin/make clean)
rm -f commandfilter.so basics.so testrdb.so fork.so infotest.so propagate.so misc.so hooks.so blockonkeys.so blockonbackground.so scan.so datatype.so datatype2.so auth.so keyspace_events.so blockedclient.so getkeys.so getchannels.so test_lazyfree.so timer.so defragtest.so keyspecs.so hash.so zset.so stream.so mallocsize.so aclcheck.so list.so subcommands.so reply.so cmdintrospection.so eventloop.so moduleconfigs.so moduleconfigstwo.so moduleparameter.so publish.so usercall.so postnotifications.so moduleauthtwo.so rdbloadsave.so crash.so cluster.so helloscripting.so commandfilter.xo basics.xo testrdb.xo fork.xo infotest.xo propagate.xo misc.xo hooks.xo blockonkeys.xo blockonbackground.xo scan.xo datatype.xo datatype2.xo auth.xo keyspace_events.xo blockedclient.xo getkeys.xo getchannels.xo test_lazyfree.xo timer.xo defragtest.xo keyspecs.xo hash.xo zset.xo stream.xo mallocsize.xo aclcheck.xo list.xo subcommands.xo reply.xo cmdintrospection.xo eventloop.xo moduleconfigs.xo moduleconfigstwo.xo moduleparameter.xo publish.xo usercall.xo postnotifications.xo moduleauthtwo.xo rdbloadsave.xo crash.xo cluster.xo helloscripting.xo
(rm -f .make-*)
echo STD=-pedantic -Wno-c11-extensions -std=gnu11 >> .make-settings
echo WARN=-Wall -W -Wno-missing-field-initializers -Werror=deprecated-declarations -Wstrict-prototypes >> .make-settings
echo OPT=-O3 -flto -fno-omit-frame-pointer >> .make-settings
echo MALLOC=libc >> .make-settings
echo BUILD_TLS= >> .make-settings
echo BUILD_RDMA= >> .make-settings
echo USE_SYSTEMD= >> .make-settings
echo CFLAGS= >> .make-settings
echo LDFLAGS= >> .make-settings
echo SERVER_CFLAGS= >> .make-settings
echo SERVER_LDFLAGS= >> .make-settings
echo PREV_FINAL_CFLAGS=-pedantic -Wno-c11-extensions -std=gnu11 -Wall -W -Wno-missing-field-initializers -Werror=deprecated-declarations -Wstrict-prototypes -O3 -flto -fno-omit-frame-pointer -g -ggdb   -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -I../deps/hdr_histogram -I../deps/fpconv >> .make-settings
echo PREV_FINAL_LDFLAGS= -O3 -flto -fno-omit-frame-pointer  -g -ggdb >> .make-settings
(cd ../deps && /Library/Developer/CommandLineTools/usr/bin/make hiredis linenoise lua hdr_histogram fpconv)
(cd hiredis && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd linenoise && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd lua && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd jemalloc && [ -f Makefile ] && /Library/Developer/CommandLineTools/usr/bin/make distclean) > /dev/null || true
(cd hdr_histogram && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd fpconv && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(cd fast_float_c_interface && /Library/Developer/CommandLineTools/usr/bin/make clean) > /dev/null || true
(rm -f .make-*)
(echo "" > .make-ldflags)
(echo "" > .make-cflags)
MAKE hiredis
cd hiredis && /Library/Developer/CommandLineTools/usr/bin/make static 
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic alloc.c
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic net.c
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic hiredis.c
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic sds.c
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic async.c
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic read.c
gcc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Werror -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g -ggdb  -pedantic sockcompat.c
ar rcs libhiredis.a alloc.o net.o hiredis.o sds.o async.o read.o sockcompat.o
/Library/Developer/CommandLineTools/usr/bin/ranlib: file: libhiredis.a(sockcompat.o) has no symbols
MAKE linenoise
cd linenoise && /Library/Developer/CommandLineTools/usr/bin/make
gcc  -Wall -Os -g  -c linenoise.c
MAKE lua
cd lua/src && /Library/Developer/CommandLineTools/usr/bin/make all CFLAGS="-Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2 " MYLDFLAGS="" AR="ar rc"
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lapi.o lapi.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lcode.o lcode.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ldebug.o ldebug.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ldo.o ldo.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ldump.o ldump.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lfunc.o lfunc.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lgc.o lgc.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o llex.o llex.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lmem.o lmem.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lobject.o lobject.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lopcodes.o lopcodes.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lparser.o lparser.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lstate.o lstate.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lstring.o lstring.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ltable.o ltable.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ltm.o ltm.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lundump.o lundump.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lvm.o lvm.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lzio.o lzio.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o strbuf.o strbuf.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o fpconv.o fpconv.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lauxlib.o lauxlib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lbaselib.o lbaselib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ldblib.o ldblib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o liolib.o liolib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lmathlib.o lmathlib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o loslib.o loslib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o ltablib.o ltablib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lstrlib.o lstrlib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o loadlib.o loadlib.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o linit.o linit.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lua_cjson.o lua_cjson.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lua_struct.o lua_struct.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lua_cmsgpack.o lua_cmsgpack.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lua_bit.o lua_bit.c
ar rc liblua.a lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o ltm.o lundump.o lvm.o lzio.o strbuf.o fpconv.o lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o loadlib.o linit.o lua_cjson.o lua_struct.o lua_cmsgpack.o lua_bit.o	# DLL needs all object files
ranlib liblua.a
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o lua.o lua.c
gcc -o lua  lua.o liblua.a -lm 
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o luac.o luac.c
gcc -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DLUA_USE_MKSTEMP  -O2    -c -o print.o print.c
gcc -o luac  luac.o print.o liblua.a -lm 
MAKE hdr_histogram
cd hdr_histogram && /Library/Developer/CommandLineTools/usr/bin/make
gcc -std=c99 -Wall -Os -g  -DHDR_MALLOC_INCLUDE=\"hdr_redis_malloc.h\" -c  hdr_histogram.c 
ar rcs libhdrhistogram.a hdr_histogram.o
MAKE fpconv
cd fpconv && /Library/Developer/CommandLineTools/usr/bin/make
gcc  -Wall -Os -g  -c  fpconv_dtoa.c 
ar rcs libfpconv.a fpconv_dtoa.o
    CC threads_mngr.o
    CC adlist.o
    CC quicklist.o
    CC ae.o
    CC anet.o
    CC dict.o
    CC hashtable.o
    CC kvstore.o
    CC server.o
    CC sds.o
    CC zmalloc.o
    CC lzf_c.o
    CC lzf_d.o
    CC pqsort.o
    CC zipmap.o
    CC sha1.o
    CC ziplist.o
    CC release.o
    CC memory_prefetch.o
    CC io_threads.o
    CC networking.o
    CC util.o
    CC object.o
    CC db.o
    CC replication.o
    CC rdb.o
    CC t_string.o
    CC t_list.o
    CC t_set.o
    CC t_zset.o
    CC t_hash.o
    CC config.o
    CC aof.o
    CC pubsub.o
    CC multi.o
    CC debug.o
    CC sort.o
    CC intset.o
    CC syncio.o
    CC cluster.o
    CC cluster_legacy.o
    CC cluster_slot_stats.o
    CC crc16.o
    CC endianconv.o
    CC commandlog.o
    CC eval.o
    CC bio.o
    CC rio.o
    CC rand.o
    CC memtest.o
    CC syscheck.o
    CC crcspeed.o
    CC crccombine.o
    CC crc64.o
    CC bitops.o
    CC sentinel.o
    CC notify.o
    CC setproctitle.o
    CC blocked.o
    CC hyperloglog.o
    CC latency.o
    CC sparkline.o
    CC valkey-check-rdb.o
    CC valkey-check-aof.o
    CC geo.o
    CC lazyfree.o
    CC module.o
    CC evict.o
    CC expire.o
    CC geohash.o
    CC geohash_helper.o
    CC childinfo.o
    CC allocator_defrag.o
    CC defrag.o
    CC siphash.o
    CC rax.o
    CC t_stream.o
    CC listpack.o
    CC localtime.o
    CC lolwut.o
    CC lolwut5.o
    CC lolwut6.o
    CC acl.o
    CC tracking.o
    CC socket.o
    CC tls.o
    CC sha256.o
    CC timeout.o
    CC setcpuaffinity.o
    CC monotonic.o
    CC mt19937-64.o
    CC resp_parser.o
    CC call_reply.o
    CC script_lua.o
    CC script.o
    CC functions.o
    CC function_lua.o
    CC commands.o
    CC strl.o
    CC connection.o
    CC unix.o
    CC logreqres.o
    CC rdma.o
    CC scripting_engine.o
    LINK valkey-server
    INSTALL valkey-sentinel
    CC valkey-cli.o
    CC serverassert.o
    CC cli_common.o
    CC cli_commands.o
    LINK valkey-cli
    CC valkey-benchmark.o
    LINK valkey-benchmark
    INSTALL valkey-check-rdb
    INSTALL valkey-check-aof

Hint: It's a good idea to run 'make test' ;)


$ ls
00-RELEASENOTES		README.md		runtest-rdma
CMakeLists.txt		SECURITY.md		runtest-sentinel
CODE_OF_CONDUCT.md	cmake			sentinel.conf
CONTRIBUTING.md		codecov.yml		src
COPYING			deps			tests
GOVERNANCE.md		runtest			utils
MAINTAINERS.md		runtest-cluster		valkey.conf
Makefile		runtest-moduleapi

$ ./src/valkey-
valkey-benchmark  valkey-check-rdb  valkey-sentinel   
valkey-check-aof  valkey-cli        valkey-server     

$ ./src/valkey-server 
5025:M 30 Jan 2025 13:41:59.012 * oO0OoO0OoO0Oo Valkey is starting oO0OoO0OoO0Oo
5025:M 30 Jan 2025 13:41:59.012 * Valkey version=255.255.255, bits=64, commit=12ec3d59, modified=0, pid=5025, just started
5025:M 30 Jan 2025 13:41:59.012 # Warning: no config file specified, using the default config. In order to specify a config file use ./src/valkey-server /path/to/valkey.conf
5025:M 30 Jan 2025 13:41:59.013 * Increased maximum number of open files to 10032 (it was originally set to 256).
5025:M 30 Jan 2025 13:41:59.013 * monotonic clock: POSIX clock_gettime
                .+^+.                                                
            .+#########+.                                            
        .+########+########+.           Valkey 255.255.255 (12ec3d59/0) 64 bit
    .+########+'     '+########+.                                    
 .########+'     .+.     '+########.    Running in standalone mode
 |####+'     .+#######+.     '+####|    Port: 6379
 |###|   .+###############+.   |###|    PID: 5025                     
 |###|   |#####*'' ''*#####|   |###|                                 
 |###|   |####'  .-.  '####|   |###|                                 
 |###|   |###(  (@@@)  )###|   |###|          https://valkey.io      
 |###|   |####.  '-'  .####|   |###|                                 
 |###|   |#####*.   .*#####|   |###|                                 
 |###|   '+#####|   |#####+'   |###|                                 
 |####+.     +##|   |#+'     .+####|                                 
 '#######+   |##|        .+########'                                 
    '+###|   |##|    .+########+'                                    
        '|   |####+########+'                                        
             +#########+'                                            
                '+v+'                                                

5025:M 30 Jan 2025 13:41:59.014 # WARNING: The TCP backlog setting of 511 cannot be enforced because kern.ipc.somaxconn is set to the lower value of 128.
5025:M 30 Jan 2025 13:41:59.015 * Server initialized
5025:M 30 Jan 2025 13:41:59.015 * Ready to accept connections tcp
^C5025:signal-handler (1738224723) Received SIGINT scheduling shutdown...
5025:M 30 Jan 2025 13:42:03.753 * User requested shutdown...
5025:M 30 Jan 2025 13:42:03.753 * Saving the final RDB snapshot before exiting.
5025:M 30 Jan 2025 13:42:03.770 * DB saved on disk
5025:M 30 Jan 2025 13:42:03.770 # Valkey is now ready to exit, bye bye...

$ ls
00-RELEASENOTES		README.md		runtest-moduleapi
CMakeLists.txt		SECURITY.md		runtest-rdma
CODE_OF_CONDUCT.md	cmake			runtest-sentinel
CONTRIBUTING.md		codecov.yml		sentinel.conf
COPYING			deps			src
GOVERNANCE.md		dump.rdb		tests
MAINTAINERS.md		runtest			utils
Makefile		runtest-cluster		valkey.conf

$ gst
On branch unstable
Your branch is up to date with 'origin/unstable'.

nothing to commit, working tree clean

$ rg redis
CONTRIBUTING.md
55:    sign-off) is maintained indefinitely and may be redistributed

valkey.conf
497:# extended-redis-compatibility no
1582:# http://antirez.com/post/redis-persistence-demystified.html

deps/Makefile
39:	-(cd hiredis && $(MAKE) clean) > /dev/null || true
54:hiredis: .make-prerequisites
56:	cd hiredis && $(MAKE) static $(HIREDIS_MAKE_FLAGS)
58:.PHONY: hiredis
96:# challenging to cross-compile lua (and redis).  These defines make it easier
97:# to fit redis into cross-compilation environments, which typically set AR.

deps/CMakeLists.txt
6:# Set hiredis options. We need to disable the defaults set in the OPTION(..) we do this by setting them in the CACHE
14:    message(STATUS "Building hiredis_ssl")
20:add_subdirectory(hiredis)
25:# Clear any cached variables passed to hiredis from the cache

src/Makefile
7:# However when building the dependencies (Jemalloc, Lua, Hiredis, ...)
34:DEPENDENCY_TARGETS=hiredis linenoise lua hdr_histogram fpconv
253:FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -I../deps/hdr_histogram -I../deps/fpconv
320:	FINAL_LIBS += ../deps/hiredis/libhiredis_ssl.a $(LIBSSL_LIBS) $(LIBCRYPTO_LIBS)
328:	TLS_CLIENT_LIBS = ../deps/hiredis/libhiredis_ssl.a $(LIBSSL_LIBS) $(LIBCRYPTO_LIBS)
364:        $(BINCOLOR)$(subst $(ENGINE_NAME),redis,$(1))$(ENDCOLOR) -\> $(BINCOLOR)$(1)$(ENDCOLOR) 1>&2
365:        @ln -sf $(1) $(2)/$(subst $(ENGINE_NAME),redis,$(1))
373:        ln -sf $(1) $(2)/$(subst $(ENGINE_NAME),redis,$(1))
382:	MAYBE_UNINSTALL_REDIS_SYMLINK=@rm -f $(1)/$(subst $(ENGINE_NAME),redis,$(2))
493:	$(SERVER_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a ../deps/hdr_histogram/libhdrhistogram.a ../deps/fpconv/libfpconv.a $(FINAL_LIBS)
501:	$(SERVER_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a ../deps/hdr_histogram/libhdrhistogram.a ../deps/fpconv/libfpconv.a $(FINAL_LIBS)
525:	$(SERVER_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS) $(TLS_CLIENT_LIBS)
529:	$(SERVER_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/hdr_histogram/libhdrhistogram.a $(FINAL_LIBS) $(TLS_CLIENT_LIBS)

deps/hdr_histogram/COPYING.txt
25:works, reuse and redistribute as freely as possible in any form whatsoever

src/tracking.c
197:        TrackingChannelName = createStringObject("__redis__:invalidate", 20);
306:     * by sending Pub/Sub messages in the __redis__:invalidate channel. */

src/aof.c
2426:        if (strstr(server.exec_argv[0], "redis-server") != NULL) {
2427:            serverSetProcTitle("redis-aof-rewrite");

src/module.c
10729: * 3. Invocation through Lua `redis.call()`.
11258:        if (strstr(server.exec_argv[0], "redis-server") != NULL) {
11259:            serverSetProcTitle("redis-module-fork");

src/networking.c
3198: * For Unix sockets we use path:0, like in "/tmp/redis:0".
4235:    addReplyBulkCString(c, server.extended_redis_compat ? "redis" : SERVER_NAME);
4238:    addReplyBulkCString(c, server.extended_redis_compat ? REDIS_VERSION : VALKEY_VERSION);
4787:     * See https://github.com/redis/redis/issues/6988 for more info.

src/sentinel.c
32:#include "hiredis.h"
35:#include "hiredis_ssl.h"
143: * same Sentinels, one per primary, and we need to share the hiredis connections
148: * hiredis connections for commands and Pub/Sub, and the fields needed for
159:    redisAsyncContext *cc;     /* Hiredis context for commands. */
160:    redisAsyncContext *pc;     /* Hiredis context for Pub / Sub. */
292:/* ======================= hiredis ae.c adapters =============================
293: * Note: this implementation is taken from hiredis/adapters/ae.h, however
298:    redisAsyncContext *context;
304:static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
310:    redisAsyncHandleRead(e->context);
313:static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
319:    redisAsyncHandleWrite(e->context);
322:static void redisAeAddRead(void *privdata) {
327:        aeCreateFileEvent(loop, e->fd, AE_READABLE, redisAeReadEvent, e);
331:static void redisAeDelRead(void *privdata) {
340:static void redisAeAddWrite(void *privdata) {
345:        aeCreateFileEvent(loop, e->fd, AE_WRITABLE, redisAeWriteEvent, e);
349:static void redisAeDelWrite(void *privdata) {
358:static void redisAeCleanup(void *privdata) {
360:    redisAeDelRead(privdata);
361:    redisAeDelWrite(privdata);
365:static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
366:    redisContext *c = &(ac->c);
380:    ac->ev.addRead = redisAeAddRead;
381:    ac->ev.delRead = redisAeDelRead;
382:    ac->ev.addWrite = redisAeAddWrite;
383:    ac->ev.delWrite = redisAeDelWrite;
384:    ac->ev.cleanup = redisAeCleanup;
392:void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);
393:void sentinelDisconnectCallback(const redisAsyncContext *c, int status);
394:void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);
398:void instanceLinkConnectionError(const redisAsyncContext *c);
405:void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);
1016:/* Disconnect a hiredis connection in the context of an instance link. */
1017:void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
1027:    redisAsyncFree(c);
1035: * pending requests in link->cc (hiredis connection for commands) to a
1043:            /* This instance may have pending callbacks in the hiredis async
1046:             * hiredis internal data structures, in order to bind them with
1048:            redisCallback *cb;
1049:            redisCallbackList *callbacks = &link->cc->replies;
1199:/* This function is called when a hiredis connection reported an error.
1203: * Note: we don't free the hiredis context as hiredis will do it for us
1205:void instanceLinkConnectionError(const redisAsyncContext *c) {
1219:/* Hiredis connection established / disconnected callbacks. We need them
1221:void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
1225:void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
1354:/* Release this instance and all its replicas, sentinels, hiredis connections.
2229:/* ====================== hiredis connection handling ======================= */
2243:void sentinelSendAuthIfNeeded(sentinelValkeyInstance *ri, redisAsyncContext *c) {
2268:        if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri, "%s %s", sentinelInstanceMapCommand(ri, "AUTH"),
2274:        if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri, "%s %s %s", sentinelInstanceMapCommand(ri, "AUTH"),
2286:void sentinelSetClientName(sentinelValkeyInstance *ri, redisAsyncContext *c, char *type) {
2290:    if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri, "%s SETNAME %s",
2296:static int instanceLinkNegotiateTLS(redisAsyncContext *context) {
2302:    if (redisInitiateSSL(&context->c, ssl) == REDIS_ERR) {
2338:        link->cc = redisAsyncConnectBind(ri->addr->ip, ri->addr->port, server.bind_source_addr);
2353:            redisAeAttach(server.el, link->cc);
2354:            redisAsyncSetConnectCallback(link->cc, sentinelLinkEstablishedCallback);
2355:            redisAsyncSetDisconnectCallback(link->cc, sentinelDisconnectCallback);
2365:        link->pc = redisAsyncConnectBind(ri->addr->ip, ri->addr->port, server.bind_source_addr);
2378:            redisAeAttach(server.el, link->pc);
2379:            redisAsyncSetConnectCallback(link->pc, sentinelLinkEstablishedCallback);
2380:            redisAsyncSetDisconnectCallback(link->pc, sentinelDisconnectCallback);
2384:            retval = redisAsyncCommand(link->pc, sentinelReceiveHelloMessages, ri, "%s %s",
2641:void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
2644:    redisReply *r;
2657:void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
2665:void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
2668:    redisReply *r;
2688:                if (redisAsyncCommand(ri->link->cc, sentinelDiscardReplyCallback, ri, "%s KILL",
2701:void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
2704:    redisReply *r;
2826:void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
2828:    redisReply *r;
2899:    retval = redisAsyncCommand(ri->link->cc, sentinelPublishReplyCallback, ri, "%s %s %s",
2944:        redisAsyncCommand(ri->link->cc, sentinelPingReplyCallback, ri, "%s", sentinelInstanceMapCommand(ri, "PING"));
3000:        retval = redisAsyncCommand(ri->link->cc, sentinelInfoReplyCallback, ri, "%s",
4430:void sentinelReceiveIsPrimaryDownReply(redisAsyncContext *c, void *reply, void *privdata) {
4433:    redisReply *r;
4498:        retval = redisAsyncCommand(
4672:    retval = redisAsyncCommand(ri->link->cc, sentinelDiscardReplyCallback, ri, "%s",
4677:    retval = redisAsyncCommand(ri->link->cc, sentinelDiscardReplyCallback, ri, "%s %s %s",
4682:    retval = redisAsyncCommand(ri->link->cc, sentinelDiscardReplyCallback, ri, "%s REWRITE",
4693:        retval = redisAsyncCommand(ri->link->cc, sentinelDiscardReplyCallback, ri, "%s KILL TYPE %s",
4700:        redisAsyncCommand(ri->link->cc, sentinelDiscardReplyCallback, ri, "%s", sentinelInstanceMapCommand(ri, "EXEC"));

src/rdb.c
102:        redis_check_rdb_main(2, argv, NULL);
1207:    int redis_bits = (sizeof(void *) == 8) ? 64 : 32;
1212:    if (rdbSaveAuxFieldStrInt(rdb, "redis-bits", redis_bits) == -1) return -1;
1616:        if (strstr(server.exec_argv[0], "redis-server") != NULL) {
1617:            serverSetProcTitle("redis-rdb-bgsave");
3139:            } else if (!strcasecmp(auxkey->ptr, "redis-ver")) {
3157:            } else if (!strcasecmp(auxkey->ptr, "redis-bits")) {
3620:        if (strstr(server.exec_argv[0], "redis-server") != NULL) {
3621:            serverSetProcTitle("redis-rdb-to-slaves");

src/valkey-benchmark.c
46:#include <sdscompat.h> /* Use hiredis' sds compat header that maps sds calls to their hi_ variants */
47:#include <sds.h>       /* Use hiredis sds. */
49:#include <hiredis.h>
53:#include <hiredis_ssl.h>
125:    struct serverConfig *redis_config;
138:    redisContext *context;
179:    struct serverConfig *redis_config;
196:static redisContext *getRedisContext(const char *ip, int port, const char *hostsocket);
242:static redisContext *getRedisContext(const char *ip, int port, const char *hostsocket) {
243:    redisContext *ctx = NULL;
244:    redisReply *reply = NULL;
246:        ctx = redisConnect(ip, port);
248:        ctx = redisConnectUnix(hostsocket);
267:        reply = redisCommand(ctx, "AUTH %s", config.conn_info.auth);
269:        reply = redisCommand(ctx, "AUTH %s %s", config.conn_info.user, config.conn_info.auth);
277:            redisFree(ctx);
290:    redisFree(ctx);
298:    redisContext *c = NULL;
299:    redisReply *reply = NULL, *sub_reply = NULL;
305:    redisAppendCommand(c, "CONFIG GET %s", "save");
306:    redisAppendCommand(c, "CONFIG GET %s", "appendonly");
311:        int res = redisGetReply(c, &r);
313:        reply = res == REDIS_OK ? ((redisReply *)r) : NULL;
328:    redisFree(c);
339:    redisFree(c);
361:    redisFree(c->context);
465:    if (redisBufferRead(c->context) != REDIS_OK) {
470:            if (redisGetReply(c->context, &reply) != REDIS_OK) {
479:                redisReply *r = reply;
655:        c->context = redisConnectNonBlock(ip, port);
657:        c->context = redisConnectUnixNonBlock(config.hostsocket);
675:    /* Suppress hiredis cleanup of unused buffers for max speed. */
690:            len = redisFormatCommand(&buf, "AUTH %s", config.conn_info.auth);
692:            len = redisFormatCommand(&buf, "AUTH %s %s", config.conn_info.user, config.conn_info.auth);
700:        int len = redisFormatCommand(&buf, "CLIENT TRACKING on");
718:        int len = redisFormatCommand(&buf, "HELLO 3");
727:        len = redisFormatCommand(&buf, "READONLY");
870:                serverConfig *cfg = node->redis_config;
877:            if (config.redis_config) {
878:                printf("  host configuration \"save\": %s\n", config.redis_config->save);
879:                printf("  host configuration \"appendonly\": %s\n", config.redis_config->appendonly);
1040:    node->redis_config = NULL;
1051:    if (node->redis_config != NULL) freeServerConfig(node->redis_config);
1076:    redisContext *ctx = NULL;
1077:    redisReply *reply = NULL;
1086:    reply = redisCommand(ctx, "CLUSTER SLOTS");
1095:        redisReply *r = reply->element[i];
1102:            redisReply *nr = r->element[j];
1155:    if (ctx) redisFree(ctx);
1176:    redisReply *reply = NULL;
1186:    redisContext *ctx = NULL;
1205:    reply = redisCommand(ctx, "CLUSTER SLOTS");
1213:        redisReply *r = reply->element[i];
1232:            redisReply *nr = r->element[j];
1255:    redisFree(ctx);
1341:            parseRedisUri(argv[++i], "redis-benchmark", &config.conn_info, &config.tls);
1569:        "   $ valkey-benchmark -r 10000 -n 10000 eval 'return redis.call(\"ping\")' 0\n\n"
1676:    config.redis_config = NULL;
1738:            node->redis_config = getServerConfig(node->ip, node->port, NULL);
1739:            if (node->redis_config == NULL) {
1748:        config.redis_config = getServerConfig(config.conn_info.hostip, config.conn_info.hostport, config.hostsocket);
1749:        if (config.redis_config == NULL) {
1808:            len = redisFormatCommandArgv(&cmd, argc, (const char **)sds_args, argvlen);
1817:        if (config.redis_config != NULL) freeServerConfig(config.redis_config);
1831:            len = redisFormatCommand(&cmd, "PING");
1837:            len = redisFormatCommand(&cmd, "SET key%s:__rand_int__ %s", tag, data);
1843:            len = redisFormatCommand(&cmd, "GET key%s:__rand_int__", tag);
1849:            len = redisFormatCommand(&cmd, "INCR counter%s:__rand_int__", tag);
1855:            len = redisFormatCommand(&cmd, "LPUSH mylist%s %s", tag, data);
1861:            len = redisFormatCommand(&cmd, "RPUSH mylist%s %s", tag, data);
1867:            len = redisFormatCommand(&cmd, "LPOP mylist%s", tag);
1873:            len = redisFormatCommand(&cmd, "RPOP mylist%s", tag);
1879:            len = redisFormatCommand(&cmd, "SADD myset%s element:__rand_int__", tag);
1885:            len = redisFormatCommand(&cmd, "HSET myhash%s element:__rand_int__ %s", tag, data);
1891:            len = redisFormatCommand(&cmd, "SPOP myset%s", tag);
1899:            len = redisFormatCommand(&cmd, "ZADD myzset%s %s element:__rand_int__", tag, score);
1905:            len = redisFormatCommand(&cmd, "ZPOPMIN myzset%s", tag);
1912:            len = redisFormatCommand(&cmd, "LPUSH mylist%s %s", tag, data);
1918:            len = redisFormatCommand(&cmd, "LRANGE mylist%s 0 99", tag);
1924:            len = redisFormatCommand(&cmd, "LRANGE mylist%s 0 299", tag);
1930:            len = redisFormatCommand(&cmd, "LRANGE mylist%s 0 499", tag);
1936:            len = redisFormatCommand(&cmd, "LRANGE mylist%s 0 599", tag);
1949:            len = redisFormatCommandArgv(&cmd, 21, cmd_argv, NULL);
1956:            len = redisFormatCommand(&cmd, "XADD mystream%s * myfield %s", tag, data);
1966:    if (config.redis_config != NULL) freeServerConfig(config.redis_config);

src/valkeymodule.h
4: * This header file is forked from redismodule.h to reflect the new naming conventions adopted in Valkey.

src/server.c
1974:/* These shared strings depend on the extended-redis-compatibility config and is
1978:    const char *name = server.extended_redis_compat ? "Redis" : SERVER_TITLE;
2219:    server.extended_redis_compat = 0;
5620:                "redis_version:%s\r\n", REDIS_VERSION,
5623:                "redis_git_sha1:%s\r\n", serverGitSHA1(),
5624:                "redis_git_dirty:%i\r\n", strtol(serverGitDirty(), NULL, 10) > 0,
5625:                "redis_build_id:%s\r\n", serverBuildIdString(),
5626:                "%s_mode:", (server.extended_redis_compat ? "redis" : "server"),
6625:    /* valkey may install symlinks like redis-sentinel -> valkey-sentinel. */
6626:    if (strstr(exec_name, "redis-sentinel") != NULL) return 1;
6914:        redis_check_rdb_main(argc, argv, NULL);
6916:        redis_check_aof_main(argc, argv);
6919:     * redis-server -> valkey-server, redis-check-rdb -> valkey-check-rdb,
6920:     * redis-check-aof -> valkey-check-aof, etc. */
6921:    if (strstr(exec_name, "redis-check-rdb") != NULL)
6922:        redis_check_rdb_main(argc, argv, NULL);
6923:    else if (strstr(exec_name, "redis-check-aof") != NULL)
6924:        redis_check_aof_main(argc, argv);

src/script_lua.h
59:#define REDIS_API_NAME "redis"

src/crccombine.c
26:  including commercial applications, and to alter it and redistribute it

src/valkey-check-rdb.c
188:int redis_check_rdb(char *rdbfilename, FILE *fp) {
389:int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
414:    int retval = redis_check_rdb(argv[1], fp);

src/config.c
3190:    createBoolConfig("extended-redis-compatibility", NULL, MODIFIABLE_CONFIG, server.extended_redis_compat, 0, NULL, updateExtendedRedisCompat),

src/commands.def
3009:{MAKE_ARG("storedistkey",ARG_TYPE_KEY,2,"STOREDIST",NULL,NULL,CMD_ARG_NONE,0,NULL),.display_text="key"},
3072:{MAKE_ARG("storedistkey",ARG_TYPE_KEY,2,"STOREDIST",NULL,NULL,CMD_ARG_NONE,0,NULL),.display_text="key"},
3380:{MAKE_ARG("storedist",ARG_TYPE_PURE_TOKEN,-1,"STOREDIST",NULL,NULL,CMD_ARG_OPTIONAL,0,NULL)},

src/db.c
2259:                                server.extended_redis_compat ? "Redis" : "Valkey");
2454:                            server.extended_redis_compat ? "Redis" : "Valkey");
2718:        /* For the case when user specifies both "store" and "storedist" options, the
2722:        if ((!strcasecmp(arg, "store") || !strcasecmp(arg, "storedist")) && ((i + 1) < argc)) {

src/valkey-check-aof.c
251:        if (redis_check_rdb_main(2, argv, fp) == C_ERR) {
518:int redis_check_aof_main(int argc, char **argv) {

src/script_lua.c
62:    "__redis__err__handler",  /* Backwards compatible error handler */
141:static void redisProtocolToLuaType_Int(void *ctx, long long val, const char *proto, size_t proto_len);
143:redisProtocolToLuaType_BulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);
144:static void redisProtocolToLuaType_NullBulkString(void *ctx, const char *proto, size_t proto_len);
145:static void redisProtocolToLuaType_NullArray(void *ctx, const char *proto, size_t proto_len);
146:static void redisProtocolToLuaType_Status(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);
147:static void redisProtocolToLuaType_Error(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);
148:static void redisProtocolToLuaType_Array(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);
149:static void redisProtocolToLuaType_Map(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);
150:static void redisProtocolToLuaType_Set(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);
151:static void redisProtocolToLuaType_Null(void *ctx, const char *proto, size_t proto_len);
152:static void redisProtocolToLuaType_Bool(void *ctx, int val, const char *proto, size_t proto_len);
153:static void redisProtocolToLuaType_Double(void *ctx, double d, const char *proto, size_t proto_len);
155:redisProtocolToLuaType_BigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);
156:static void redisProtocolToLuaType_VerbatimString(void *ctx,
162:static void redisProtocolToLuaType_Attribute(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);
225:    .null_array_callback = redisProtocolToLuaType_NullArray,
226:    .bulk_string_callback = redisProtocolToLuaType_BulkString,
227:    .null_bulk_string_callback = redisProtocolToLuaType_NullBulkString,
228:    .error_callback = redisProtocolToLuaType_Error,
229:    .simple_str_callback = redisProtocolToLuaType_Status,
230:    .long_callback = redisProtocolToLuaType_Int,
231:    .array_callback = redisProtocolToLuaType_Array,
232:    .set_callback = redisProtocolToLuaType_Set,
233:    .map_callback = redisProtocolToLuaType_Map,
234:    .bool_callback = redisProtocolToLuaType_Bool,
235:    .double_callback = redisProtocolToLuaType_Double,
236:    .null_callback = redisProtocolToLuaType_Null,
237:    .big_number_callback = redisProtocolToLuaType_BigNumber,
238:    .verbatim_string_callback = redisProtocolToLuaType_VerbatimString,
239:    .attribute_callback = redisProtocolToLuaType_Attribute,
243:static void redisProtocolToLuaType(lua_State *lua, char *reply) {
249:static void redisProtocolToLuaType_Int(void *ctx, long long val, const char *proto, size_t proto_len) {
265:static void redisProtocolToLuaType_NullBulkString(void *ctx, const char *proto, size_t proto_len) {
281:static void redisProtocolToLuaType_NullArray(void *ctx, const char *proto, size_t proto_len) {
298:redisProtocolToLuaType_BulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
314:static void redisProtocolToLuaType_Status(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
333:static void redisProtocolToLuaType_Error(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
355:static void redisProtocolToLuaType_Map(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
376:static void redisProtocolToLuaType_Set(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
397:                 * call to redisProtocolToLuaType might have use the room allocated in the stack*/
407:static void redisProtocolToLuaType_Array(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
426:static void redisProtocolToLuaType_Attribute(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
442:static void redisProtocolToLuaType_VerbatimString(void *ctx,
473:redisProtocolToLuaType_BigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
492:static void redisProtocolToLuaType_Null(void *ctx, const char *proto, size_t proto_len) {
508:static void redisProtocolToLuaType_Bool(void *ctx, int val, const char *proto, size_t proto_len) {
524:static void redisProtocolToLuaType_Double(void *ctx, double d, const char *proto, size_t proto_len) {
980:    redisProtocolToLuaType(lua, reply);
1531:     * We will also alias it to 'redis' global var for backwards compatibility. */
1534:     * lua_setglobal invocation uses the value from stack to set 'redis' global variable.

src/server.h
1793:    int extended_redis_compat;                 /* True if extended Redis OSS compatibility is enabled */
2020:    /* Zip structure config, see redis.conf for more information  */
2382: *                    And should be removed from redis.
3505:int redis_check_rdb(char *rdbfilename, FILE *fp);
3506:int redis_check_rdb_main(int argc, char **argv, FILE *fp);
3507:int redis_check_aof_main(int argc, char **argv);

deps/jemalloc/build-aux/config.sub
7:# This file is free software; you can redistribute it and/or modify it

src/resp_parser.c
32: * 'redis.call()'.

deps/jemalloc/build-aux/config.guess
7:# This file is free software; you can redistribute it and/or modify it

src/tls.c
327:        SSL_CTX_set_session_id_context(ctx, (void *)"redis", 5);

src/cluster_legacy.c
5478:         * See https://github.com/redis/redis/issues/3043 for more info. */

src/script.c
174:                                        server.extended_redis_compat ? "Redis" : SERVER_TITLE);
181:                                        server.extended_redis_compat ? "Redis" : SERVER_TITLE,

src/commands/georadius.json
202:                        "name": "storedistkey",

src/commands/georadiusbymember.json
197:                        "name": "storedistkey",

src/commands/geosearchstore.json
217:                "name": "storedist",

src/cli_common.c
39:#include <hiredis.h>
40:#include <sdscompat.h> /* Use hiredis' sds compat header that maps sds calls to their hi_ variants */
41:#include <sds.h>       /* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
48:#include <hiredis_ssl.h>
56:/* Wrapper around redisSecureConnection to avoid hiredis_ssl dependencies if
59:int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err) {
117:    return redisInitiateSSL(c, ssl);
131:/* Wrapper around hiredis to allow arbitrary reads and writes.
133: * We piggybacks on top of hiredis to achieve transparent TLS support,
141:/* Write a raw buffer through a redisContext. If we already have something
142: * in the buffer (leftovers from hiredis operations) it will be written
145:ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len) {
152:    if (redisBufferWrite(c, &done) == REDIS_ERR) {
310: *  [1]: https://www.iana.org/assignments/uri-schemes/prov/redis */
320:    /* We need to support redis:// and rediss:// too for compatibility. */
321:    const char *redisScheme = "redis://";
322:    const char *redisTlsscheme = "rediss://";
329:        !strncasecmp(redisTlsscheme, curr, strlen(redisTlsscheme))) {
341:    } else if (!strncasecmp(scheme, curr, strlen(scheme)) || !strncasecmp(redisScheme, curr, strlen(redisScheme))) {
430:/* This is a wrapper to call redisConnect or redisConnectWithTimeout. */
431:redisContext *redisConnectWrapper(const char *ip, int port, const struct timeval tv) {
433:        return redisConnect(ip, port);
435:        return redisConnectWithTimeout(ip, port, tv);
439:/* This is a wrapper to call redisConnectUnix or redisConnectUnixWithTimeout. */
440:redisContext *redisConnectUnixWrapper(const char *path, const struct timeval tv) {
442:        return redisConnectUnix(path);
444:        return redisConnectUnixWithTimeout(path, tv);

src/debug.c
1165:                  server.extended_redis_compat ? "REDIS" : "VALKEY");
2233:                         server.extended_redis_compat ? "REDIS" : "VALKEY");

src/unit/test_rax.c
342:     * be replaced with the binary redis cluster hash slot. */

deps/hdr_histogram/Makefile
5:R_CFLAGS= $(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) -DHDR_MALLOC_INCLUDE=\"hdr_redis_malloc.h\"

src/unit/test_util.c
308:    char *tmpfile = "/tmp/redis-reclaim-cache-test";

src/unit/CMakeLists.txt
51:    hiredis
56:    target_link_libraries(valkey-unit-tests OpenSSL::SSL hiredis_ssl)

deps/hdr_histogram/CMakeLists.txt
4:         "${CMAKE_CURRENT_LIST_DIR}/hdr_atomic.h" "${CMAKE_CURRENT_LIST_DIR}/hdr_redis_malloc.h")
7:target_compile_definitions(hdr_histogram PRIVATE HDR_MALLOC_INCLUDE=\"hdr_redis_malloc.h\")

src/CMakeLists.txt
15:                             "redis-server")
43:valkey_build_and_install_bin(valkey-cli "${VALKEY_CLI_SRCS}" "${VALKEY_SERVER_LDFLAGS}" "${CLI_LIBS}" "redis-cli")
50:                             "redis-benchmark")
81:    target_link_libraries(${MODULE_NAME} hiredis_ssl OpenSSL::SSL)

src/valkey-cli.c
49:#include <hiredis.h>
53:#include <hiredis_ssl.h>
55:#include <sdscompat.h> /* Use hiredis' sds compat header that maps sds calls to their hi_ variants */
56:#include <sds.h>       /* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
98:#define CLUSTER_MANAGER_COMMAND(n, ...) (redisCommand((n)->context, __VA_ARGS__))
207:static redisContext *context;
264:    redisReply *last_reply;
423:    redisReply *reply = redisCommand(context, "COMMAND");
429:        redisReply *entry = reply->element[j];
482:static void cliAddCommandDocArg(cliCommandArg *cmdArg, redisReply *argMap);
484:static void cliMakeCommandDocArgs(redisReply *arguments, cliCommandArg *result) {
490:static void cliAddCommandDocArg(cliCommandArg *cmdArg, redisReply *argMap) {
530:            redisReply *arguments = argMap->element[i + 1];
535:            redisReply *flags = argMap->element[i + 1];
590:cliInitCommandHelpEntry(char *cmdname, char *subcommandname, helpEntry *next, redisReply *specs, dict *groups) {
599:            redisReply *reply = specs->element[j + 1];
603:            redisReply *reply = specs->element[j + 1];
607:            redisReply *reply = specs->element[j + 1];
615:            redisReply *arguments = specs->element[j + 1];
622:            redisReply *subcommands = specs->element[j + 1];
627:                redisReply *subcommand = subcommands->element[i + 1];
637:static size_t cliCountCommands(redisReply *commandTable) {
645:        redisReply *map = commandTable->element[i + 1];
650:                redisReply *subcommands = map->element[j + 1];
699:void cliInitCommandHelpEntries(redisReply *commandTable, dict *groups) {
707:        redisReply *cmdspecs = commandTable->element[i + 1];
830:    redisReply *serverInfo = NULL;
838:    serverInfo = redisCommand(context, "INFO SERVER");
890:    redisReply *commandTable;
900:    commandTable = redisCommand(context, "COMMAND DOCS");
1532:static int cliAuth(redisContext *ctx, char *user, char *auth) {
1533:    redisReply *reply;
1537:        reply = redisCommand(ctx, "AUTH %s", auth);
1539:        reply = redisCommand(ctx, "AUTH %s %s", user, auth);
1557:    redisReply *reply;
1560:    reply = redisCommand(context, "SELECT %d", config.conn_info.input_dbnum);
1580:    redisReply *reply;
1583:    reply = redisCommand(context, "HELLO 3");
1620:            redisFree(context);
1629:            context = redisConnectWrapper(config.conn_info.hostip, config.conn_info.hostport, config.connect_timeout);
1631:            context = redisConnectUnixWrapper(config.hostsocket, config.connect_timeout);
1638:                redisFree(context);
1653:            redisFree(context);
1676:        redisSetPushCallback(context, cliPushHandler);
1685:    redisReply *reply;
1691:    reply = redisCommand(context, "ASKING");
1710:static int isInvalidateReply(redisReply *reply) {
1718:static sds cliFormatInvalidateTTY(redisReply *r) {
1722:        redisReply *key = r->element[1]->element[i];
1733:static int cliIsMultilineValueTTY(redisReply *r) {
1749:static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
1858:int isPubsubPush(redisReply *r) {
1911:    if (strstr(s, "<redis>")) color = "green";
1925:static sds cliFormatReplyRaw(redisReply *r) {
1990:static sds cliFormatReplyCSV(redisReply *r) {
2049:static sds cliFormatReplyJson(sds out, redisReply *r, int mode) {
2077:            redisReply *key = r->element[i];
2106:static sds cliFormatReply(redisReply *reply, int mode, int verbatim) {
2149:    redisReply *reply;
2158:    if (redisGetReply(context, &_reply) != REDIS_OK) {
2167:            redisFree(context);
2181:    config.last_reply = reply = (redisReply *)_reply;
2235:static void handlePubSubMode(redisReply *reply) {
2263:        redisReply *reply;
2265:            if (redisGetReplyFromReader(context, (void **)&reply) != REDIS_OK) {
2349:         * https://github.com/artix75/redis-cluster-proxy */
2385:        redisAppendCommandArgv(context, argc, (const char **)argv, argvlen);
2404:            /* When a push callback is set, redisGetReply (hiredis) loops until
2410:            redisSetPushCallback(context, NULL);
2472:                    redisSetPushCallback(context, cliPushHandler);
2484:                if (config.push_output) redisSetPushCallback(context, cliPushHandler);
2503:static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
2504:    redisReply *reply = NULL;
2515:            redisFree(c);
2516:            c = redisConnectWrapper(config.conn_info.hostip, config.conn_info.hostport, config.connect_timeout);
2528:        reply = redisvCommand(c, fmt, ap);
3098:            redisFree(context);
3474:            redisReply *reply = redisCommand(context, config.eval_ldb_sync ? "SCRIPT DEBUG sync" : "SCRIPT DEBUG yes");
3532:    redisContext *context;
3600:typedef int (*clusterManagerOnReplyError)(redisReply *reply, clusterManagerNode *n, int bulk_idx);
3800:    if (node->context != NULL) redisFree(node->context);
3895:static int clusterManagerCheckRedisReply(clusterManagerNode *n, redisReply *r, char **err) {
3912:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "MULTI");
3920:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "EXEC");
3929:            redisReply *r = reply->element[i];
3946:    if (node->context) redisFree(node->context);
3947:    node->context = redisConnectWrapper(node->ip, node->port, config.connect_timeout);
3952:            redisFree(node->context);
3960:        redisFree(node->context);
3970:        redisReply *reply;
3972:            reply = redisCommand(node->context, "AUTH %s", config.conn_info.auth);
3974:            reply = redisCommand(node->context, "AUTH %s %s", config.conn_info.user, config.conn_info.auth);
4045:static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node, char **err) {
4046:    redisReply *info = CLUSTER_MANAGER_COMMAND(node, "INFO");
4061:    redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
4071:    redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
4474:            redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "DBSIZE");
4497:    redisReply *reply = NULL;
4522:    redisAppendCommandArgv(node->context, argc, (const char **)argv, argvlen);
4523:    if (redisGetReply(node->context, &_reply) != REDIS_OK) {
4527:    reply = (redisReply *)_reply;
4546:    redisReply *reply = CLUSTER_MANAGER_COMMAND(n, "CLUSTER SLOTS");
4551:            redisReply *r = reply->element[i];
4557:            redisReply *nr = r->element[2];
4588:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node1,
4613:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER SETSLOT %d %s", slot, "STABLE");
4620:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER DELSLOTS %d", slot);
4644:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER ADDSLOTS %d", slot);
4651:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER COUNTKEYSINSLOT %d", slot);
4660:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER BUMPEPOCH");
4669:static int clusterManagerOnSetOwnerErr(redisReply *reply, clusterManagerNode *n, int bulk_idx) {
4701:                                           redisReply *keys_reply,
4714:        redisReply *entry = keys_reply->element[i];
4721:    redisReply *r1 = NULL, *r2 = NULL;
4722:    redisAppendCommandArgv(n1->context, argc, (const char **)argv, argv_len);
4723:    success = (redisGetReply(n1->context, &_reply1) == REDIS_OK);
4728:    r1 = (redisReply *)_reply1;
4729:    redisAppendCommandArgv(n2->context, argc, (const char **)argv, argv_len);
4730:    success = (redisGetReply(n2->context, &_reply2) == REDIS_OK);
4735:    r2 = (redisReply *)_reply2;
4774:static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
4776:                                                    redisReply *reply,
4780:    redisReply *migrate_reply = NULL;
4835:        redisReply *entry = reply->element[i];
4844:    redisAppendCommandArgv(source->context, argc, (const char **)argv, argv_len);
4845:    int success = (redisGetReply(source->context, &_reply) == REDIS_OK);
4848:    migrate_reply = (redisReply *)_reply;
4868:        redisReply *reply = NULL, *migrate_reply = NULL;
5117:    redisReply *reply = NULL;
5205:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
5469:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
5585:    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
5723:        redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER COUNTKEYSINSLOT %d", slot);
5822:                redisReply *reply = CLUSTER_MANAGER_COMMAND(n, "CLUSTER GETKEYSINSLOT %d %d", i, 1);
6025:            redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER COUNTKEYSINSLOT %d", slot);
6079:            redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER COUNTKEYSINSLOT %d", slot);
6274:                redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER GETKEYSINSLOT %d %d", slot, 10);
6290:            redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER SETSLOT %d %s", slot, "STABLE");
6871:            redisReply *reply = NULL;
6884:                /* Although hiredis supports connecting to a hostname, CLUSTER
6896:            redisReply *reply = NULL;
6972:    redisReply *reply = NULL;
6973:    redisReply *function_restore_reply = NULL;
6974:    redisReply *function_list_reply = NULL;
7162:            redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER REPLICATE %s", primary->name);
7167:        redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER FORGET %s", node_id);
7176:    redisReply *r = redisCommand(node->context, "CLUSTER RESET %s", "SOFT");
7605:        redisReply *reply = CLUSTER_MANAGER_COMMAND(n, "CONFIG %s %s %d", "SET", "cluster-node-timeout", timeout);
7662:    redisReply *src_reply = NULL;
7664:    redisContext *src_ctx = redisConnectWrapper(src_ip, src_port, config.connect_timeout);
7750:            redisReply *kr = src_reply->element[1]->element[i];
7756:            redisReply *r = reconnectingRedisCommand(src_ctx, cmdfmt, target->ip, target->port, key, 0, timeout);
7772:    if (src_ctx) redisFree(src_ctx);
7806:        redisReply *reply = NULL;
7807:        redisAppendCommandArgv(n->context, argc, (const char **)argv, argvlen);
7808:        int status = redisGetReply(n->context, (void **)(&reply));
7960:    redisReply *reply;
8080:    redisReply *reply;
8163:    redisReply *reply = redisCommand(context, "REPLCONF %s %s", arg1, arg2);
8186:/* Read raw bytes through a redisContext. The read operation is not greedy
8189:static ssize_t readConn(redisContext *c, char *buf, size_t len) {
8203:unsigned long long sendSync(redisContext *c, int send_sync, char *out_eof, int *out_full_mode) {
8205:     * The hiredis client lib does not understand this part of the protocol
8340:    /* Now we can use hiredis to read the incoming protocol. */
8354:    redisContext *s;
8429:    redisFree(s); /* Close the connection ASAP as fsync() may take time. */
8452:    redisReply *reply;
8481:                if (!read_error && redisBufferRead(context) == REDIS_ERR) {
8486:                if (redisGetReply(context, (void **)&reply) == REDIS_ERR) {
8596:static redisReply *sendScan(unsigned long long *it) {
8597:    redisReply *reply;
8600:        reply = redisCommand(context, "SCAN %llu MATCH %b COUNT %d", *it, config.pattern, sdslen(config.pattern),
8603:        reply = redisCommand(context, "SCAN %llu COUNT %d", *it, config.count);
8631:    redisReply *reply;
8634:    reply = redisCommand(context, "DBSIZE");
8655:    redisReply *reply;
8658:    reply = redisCommand(context, "CONFIG GET databases");
8718:static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
8719:    redisReply *reply;
8726:        redisAppendCommandArgv(context, 2, argv, lens);
8731:        if (redisGetReply(context, (void **)&reply) != REDIS_OK) {
8758:getKeySizes(redisReply *keys, typeinfo **types, unsigned long long *sizes, int memkeys, unsigned memkeys_samples) {
8759:    redisReply *reply;
8770:            redisAppendCommandArgv(context, 2, argv, lens);
8774:            redisAppendCommandArgv(context, 3, argv, lens);
8779:            redisAppendCommandArgv(context, 5, argv, lens);
8793:        if (redisGetReply(context, (void **)&reply) != REDIS_OK) {
8819:    redisReply *read_reply;
8820:    read_reply = redisCommand(context, "READONLY");
8834:    redisReply *reply, *keys;
8966:static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
8967:    redisReply *reply;
8974:        redisAppendCommandArgv(context, 3, argv, lens);
8979:        if (redisGetReply(context, (void **)&reply) != REDIS_OK) {
9003:    redisReply *keys, *reply;
9159:    redisReply *reply;
9244:    redisReply *reply;
9294:    redisReply *reply;
9313:                redisAppendCommand(context, "SET %s %s", key, val);
9315:            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) redisGetReply(context, (void **)&reply);
9320:                redisAppendCommand(context, "GET %s", key);
9323:                if (redisGetReply(context, (void **)&reply) == REDIS_OK) {

src/cli_common.h
4:#include <hiredis.h>
5:#include <sdscompat.h> /* Use hiredis' sds compat header that maps sds calls to their hi_ variants */
36:int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err);
38:ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len);
56:redisContext *redisConnectWrapper(const char *ip, int port, const struct timeval tv);
57:redisContext *redisConnectUnixWrapper(const char *path, const struct timeval tv);

src/geo.c
514:    int storedist = 0; /* 0 for STORE, 1 for STOREDIST. */
587:                storedist = 0;
589:            } else if (!strcasecmp(arg, "storedist") && (i + 1) < remaining && !(flags & RADIUS_NOSTORE) &&
592:                storedist = 1;
594:            } else if (!strcasecmp(arg, "storedist") && (flags & GEOSEARCH) && (flags & GEOSEARCHSTORE)) {
595:                storedist = 1;
771:            double score = storedist ? gp->dist : gp->score;

src/eval.c
212:    /* register debug commands. we only need to add it under 'server' as 'redis' is effectively aliased to 'server'
256:        /* Duplicate the function with __redis__err_handler name for backwards compatibility */
258:        lua_setglobal(lua, "__redis__err__handler");
1670:        } else if (argc > 1 && ((!strcasecmp(argv[0], "r") || !strcasecmp(argv[0], "redis")) ||
1673:            /* [r]redis or [v]alkey calls a command. We accept "server" too, but

deps/hiredis/alloc.h
42:typedef struct hiredisAllocFuncs {
48:} hiredisAllocFuncs;
50:hiredisAllocFuncs hiredisSetAllocators(hiredisAllocFuncs *ha);
51:void hiredisResetAllocators(void);
55:/* Hiredis' configured allocator function pointer struct */
56:extern hiredisAllocFuncs hiredisAllocFns;
59:    return hiredisAllocFns.mallocFn(size);
67:    return hiredisAllocFns.callocFn(nmemb, size);
71:    return hiredisAllocFns.reallocFn(ptr, size);
75:    return hiredisAllocFns.strdupFn(str);
79:    hiredisAllocFns.freeFn(ptr);

deps/hiredis/async.c
55:/* Forward declarations of hiredis.c functions */
56:int __redisAppendCommand(redisContext *c, const char *cmd, size_t len);
57:void __redisSetError(redisContext *c, int type, const char *str);
67:    redisCallback *dup;
106:static redisAsyncContext *redisAsyncInitialize(redisContext *c) {
107:    redisAsyncContext *ac;
118:    ac = hi_realloc(c,sizeof(redisAsyncContext));
162: * an indirection to the redisContext struct. */
163:static void __redisAsyncCopyError(redisAsyncContext *ac) {
167:    redisContext *c = &(ac->c);
172:redisAsyncContext *redisAsyncConnectWithOptions(const redisOptions *options) {
173:    redisOptions myOptions = *options;
174:    redisContext *c;
175:    redisAsyncContext *ac;
183:    c = redisConnectWithOptions(&myOptions);
188:    ac = redisAsyncInitialize(c);
190:        redisFree(c);
195:    redisAsyncSetPushCallback(ac, myOptions.async_push_cb);
197:    __redisAsyncCopyError(ac);
201:redisAsyncContext *redisAsyncConnect(const char *ip, int port) {
202:    redisOptions options = {0};
204:    return redisAsyncConnectWithOptions(&options);
207:redisAsyncContext *redisAsyncConnectBind(const char *ip, int port,
209:    redisOptions options = {0};
212:    return redisAsyncConnectWithOptions(&options);
215:redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,
217:    redisOptions options = {0};
221:    return redisAsyncConnectWithOptions(&options);
224:redisAsyncContext *redisAsyncConnectUnix(const char *path) {
225:    redisOptions options = {0};
227:    return redisAsyncConnectWithOptions(&options);
231:redisAsyncSetConnectCallbackImpl(redisAsyncContext *ac, redisConnectCallback *fn,
232:                                 redisConnectCallbackNC *fn_nc)
252:int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn) {
253:    return redisAsyncSetConnectCallbackImpl(ac, fn, NULL);
256:int redisAsyncSetConnectCallbackNC(redisAsyncContext *ac, redisConnectCallbackNC *fn) {
257:    return redisAsyncSetConnectCallbackImpl(ac, NULL, fn);
260:int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn) {
269:static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {
270:    redisCallback *cb;
291:static int __redisShiftCallback(redisCallbackList *list, redisCallback *target) {
292:    redisCallback *cb = list->head;
307:static void __redisRunCallback(redisAsyncContext *ac, redisCallback *cb, redisReply *reply) {
308:    redisContext *c = &(ac->c);
316:static void __redisRunPushCallback(redisAsyncContext *ac, redisReply *reply) {
324:static void __redisRunConnectCallback(redisAsyncContext *ac, int status)
347:static void __redisRunDisconnectCallback(redisAsyncContext *ac, int status)
362:static void __redisAsyncFree(redisAsyncContext *ac) {
363:    redisContext *c = &(ac->c);
364:    redisCallback cb;
369:    while (__redisShiftCallback(&ac->replies,&cb) == REDIS_OK)
370:        __redisRunCallback(ac,&cb,NULL);
371:    while (__redisShiftCallback(&ac->sub.replies,&cb) == REDIS_OK)
372:        __redisRunCallback(ac,&cb,NULL);
378:            __redisRunCallback(ac,dictGetEntryVal(de),NULL);
386:            __redisRunCallback(ac,dictGetEntryVal(de),NULL);
394:    /* Execute disconnect callback. When redisAsyncFree() initiated destroying
400:        __redisRunDisconnectCallback(ac, status);
408:    redisFree(c);
412: * control needs to be returned to redisProcessCallbacks() before actual
414: * redisProcessCallbacks(). Otherwise, the context is immediately free'd. */
415:void redisAsyncFree(redisAsyncContext *ac) {
419:    redisContext *c = &(ac->c);
423:        __redisAsyncFree(ac);
427:void __redisAsyncDisconnect(redisAsyncContext *ac) {
428:    redisContext *c = &(ac->c);
431:    __redisAsyncCopyError(ac);
435:        int ret = __redisShiftCallback(&ac->replies,NULL);
447:    /* For non-clean disconnects, __redisAsyncFree() will execute pending
450:      __redisAsyncFree(ac);
458: * to redisProcessCallbacks(). Otherwise, we can only disconnect immediately
460:void redisAsyncDisconnect(redisAsyncContext *ac) {
461:    redisContext *c = &(ac->c);
467:        __redisAsyncDisconnect(ac);
470:static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply, redisCallback *dstcb) {
471:    redisContext *c = &(ac->c);
473:    redisCallback *cb = NULL;
481:     * https://redis.io/topics/pubsub#format-of-pushed-messages */
528:                redisCallback cb;
529:                while (__redisShiftCallback(&ac->sub.replies,&cb) == REDIS_OK) {
530:                    __redisPushCallback(&ac->replies,&cb);
537:        __redisShiftCallback(&ac->sub.replies,dstcb);
541:    __redisSetError(&(ac->c), REDIS_ERR_OOM, "Out of memory");
542:    __redisAsyncCopyError(ac);
546:#define redisIsSpontaneousPushReply(r) \
547:    (redisIsPushReply(r) && !redisIsSubscribeReply(r))
549:static int redisIsSubscribeReply(redisReply *reply) {
570:void redisProcessCallbacks(redisAsyncContext *ac) {
571:    redisContext *c = &(ac->c);
575:    while((status = redisGetReply(c,&reply)) == REDIS_OK) {
581:                __redisAsyncDisconnect(ac);
590:        if (redisIsPushReply(reply)) c->flags |= REDIS_SUPPORTS_PUSH;
596:        if (redisIsSpontaneousPushReply(reply)) {
597:            __redisRunPushCallback(ac, reply);
604:        redisCallback cb = {NULL, NULL, 0, 0, NULL};
605:        if (__redisShiftCallback(&ac->replies,&cb) != REDIS_OK) {
621:            if (((redisReply*)reply)->type == REDIS_REPLY_ERROR) {
623:                snprintf(c->errstr,sizeof(c->errstr),"%s",((redisReply*)reply)->str);
625:                __redisAsyncDisconnect(ac);
631:                __redisGetSubscribeCallback(ac,reply,&cb);
635:            __redisRunCallback(ac,&cb,reply);
640:            /* Proceed with free'ing when redisAsyncFree() was called. */
642:                __redisAsyncFree(ac);
655:            __redisPushCallback(&ac->replies,&cb);
661:        __redisAsyncDisconnect(ac);
664:static void __redisAsyncHandleConnectFailure(redisAsyncContext *ac) {
665:    __redisRunConnectCallback(ac, REDIS_ERR);
666:    __redisAsyncDisconnect(ac);
672:static int __redisAsyncHandleConnect(redisAsyncContext *ac) {
674:    redisContext *c = &(ac->c);
676:    if (redisCheckConnectDone(c, &completed) == REDIS_ERR) {
678:        if (redisCheckSocketError(c) == REDIS_ERR)
679:            __redisAsyncCopyError(ac);
680:        __redisAsyncHandleConnectFailure(ac);
685:            redisSetTcpNoDelay(c) == REDIS_ERR) {
686:            __redisAsyncHandleConnectFailure(ac);
695:        __redisRunConnectCallback(ac, REDIS_OK);
697:            redisAsyncDisconnect(ac);
700:            redisAsyncFree(ac);
709:void redisAsyncRead(redisAsyncContext *ac) {
710:    redisContext *c = &(ac->c);
712:    if (redisBufferRead(c) == REDIS_ERR) {
713:        __redisAsyncDisconnect(ac);
717:        redisProcessCallbacks(ac);
724:void redisAsyncHandleRead(redisAsyncContext *ac) {
725:    redisContext *c = &(ac->c);
731:        if (__redisAsyncHandleConnect(ac) != REDIS_OK)
741:void redisAsyncWrite(redisAsyncContext *ac) {
742:    redisContext *c = &(ac->c);
745:    if (redisBufferWrite(c,&done) == REDIS_ERR) {
746:        __redisAsyncDisconnect(ac);
759:void redisAsyncHandleWrite(redisAsyncContext *ac) {
760:    redisContext *c = &(ac->c);
766:        if (__redisAsyncHandleConnect(ac) != REDIS_OK)
776:void redisAsyncHandleTimeout(redisAsyncContext *ac) {
777:    redisContext *c = &(ac->c);
778:    redisCallback cb;
796:        __redisSetError(c, REDIS_ERR_TIMEOUT, "Timeout");
797:        __redisAsyncCopyError(ac);
801:        __redisRunConnectCallback(ac, REDIS_ERR);
804:    while (__redisShiftCallback(&ac->replies, &cb) == REDIS_OK) {
805:        __redisRunCallback(ac, &cb, NULL);
812:    __redisAsyncDisconnect(ac);
831:/* Helper function for the redisAsyncCommand* family of functions. Writes a
834:static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {
835:    redisContext *c = &(ac->c);
836:    redisCallback cb;
840:    redisCallback *existcb;
946:        if (__redisPushCallback(&ac->replies,&cb) != REDIS_OK)
950:            if (__redisPushCallback(&ac->sub.replies,&cb) != REDIS_OK)
953:            if (__redisPushCallback(&ac->replies,&cb) != REDIS_OK)
958:    __redisAppendCommand(c,cmd,len);
965:    __redisSetError(&(ac->c), REDIS_ERR_OOM, "Out of memory");
966:    __redisAsyncCopyError(ac);
970:int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap) {
974:    len = redisvFormatCommand(&cmd,format,ap);
980:    status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
985:int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...) {
989:    status = redisvAsyncCommand(ac,fn,privdata,format,ap);
994:int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen) {
998:    len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
1001:    status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
1006:int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {
1007:    int status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
1011:redisAsyncPushFn *redisAsyncSetPushCallback(redisAsyncContext *ac, redisAsyncPushFn *fn) {
1012:    redisAsyncPushFn *old = ac->push_cb;
1017:int redisAsyncSetTimeout(redisAsyncContext *ac, struct timeval tv) {
1021:            __redisSetError(&ac->c, REDIS_ERR_OOM, "Out of memory");
1022:            __redisAsyncCopyError(ac);

deps/hiredis/hiredis.c
41:#include "hiredis.h"
47:extern int redisContextUpdateConnectTimeout(redisContext *c, const struct timeval *timeout);
48:extern int redisContextUpdateCommandTimeout(redisContext *c, const struct timeval *timeout);
50:static redisContextFuncs redisContextDefaultFuncs = {
51:    .close = redisNetClose,
53:    .async_read = redisAsyncRead,
54:    .async_write = redisAsyncWrite,
55:    .read = redisNetRead,
56:    .write = redisNetWrite
59:static redisReply *createReplyObject(int type);
60:static void *createStringObject(const redisReadTask *task, char *str, size_t len);
61:static void *createArrayObject(const redisReadTask *task, size_t elements);
62:static void *createIntegerObject(const redisReadTask *task, long long value);
63:static void *createDoubleObject(const redisReadTask *task, double value, char *str, size_t len);
64:static void *createNilObject(const redisReadTask *task);
65:static void *createBoolObject(const redisReadTask *task, int bval);
69:static redisReplyObjectFunctions defaultFunctions = {
80:static redisReply *createReplyObject(int type) {
81:    redisReply *r = hi_calloc(1,sizeof(*r));
92:    redisReply *r = reply;
125:static void *createStringObject(const redisReadTask *task, char *str, size_t len) {
126:    redisReply *r, *parent;
174:static void *createArrayObject(const redisReadTask *task, size_t elements) {
175:    redisReply *r, *parent;
182:        r->element = hi_calloc(elements,sizeof(redisReply*));
202:static void *createIntegerObject(const redisReadTask *task, long long value) {
203:    redisReply *r, *parent;
222:static void *createDoubleObject(const redisReadTask *task, double value, char *str, size_t len) {
223:    redisReply *r, *parent;
259:static void *createNilObject(const redisReadTask *task) {
260:    redisReply *r, *parent;
277:static void *createBoolObject(const redisReadTask *task, int bval) {
278:    redisReply *r, *parent;
298: * Implementation borrowed from link in redis/src/util.c:string2ll(). */
316:int redisvFormatCommand(char **target, const char *format, va_list ap) {
562: * len = redisFormatCommand(target, "GET %s", mykey);
563: * len = redisFormatCommand(target, "SET %s %b", mykey, myval, myvallen);
565:int redisFormatCommand(char **target, const char *format, ...) {
569:    len = redisvFormatCommand(target,format,ap);
586:long long redisFormatSdsCommandArgv(hisds *target, int argc, const char **argv,
633:void redisFreeSdsCommand(hisds cmd) {
642:long long redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {
680:void redisFreeCommand(char *cmd) {
684:void __redisSetError(redisContext *c, int type, const char *str) {
700:redisReader *redisReaderCreate(void) {
701:    return redisReaderCreateWithFunctions(&defaultFunctions);
704:static void redisPushAutoFree(void *privdata, void *reply) {
709:static redisContext *redisContextInit(void) {
710:    redisContext *c;
716:    c->funcs = &redisContextDefaultFuncs;
719:    c->reader = redisReaderCreate();
723:        redisFree(c);
730:void redisFree(redisContext *c) {
739:    redisReaderFree(c->reader);
757:redisFD redisFreeKeepFd(redisContext *c) {
758:    redisFD fd = c->fd;
760:    redisFree(c);
764:int redisReconnect(redisContext *c) {
778:    redisReaderFree(c->reader);
781:    c->reader = redisReaderCreate();
784:        __redisSetError(c, REDIS_ERR_OOM, "Out of memory");
790:        ret = redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,
793:        ret = redisContextConnectUnix(c, c->unix_sock.path, c->connect_timeout);
797:        __redisSetError(c,REDIS_ERR_OTHER,"Not enough information to reconnect");
802:        redisContextSetTimeout(c, *c->command_timeout);
808:redisContext *redisConnectWithOptions(const redisOptions *options) {
809:    redisContext *c = redisContextInit();
835:        redisSetPushCallback(c, options->push_cb);
837:        redisSetPushCallback(c, redisPushAutoFree);
842:    if (redisContextUpdateConnectTimeout(c, options->connect_timeout) != REDIS_OK ||
843:        redisContextUpdateCommandTimeout(c, options->command_timeout) != REDIS_OK) {
844:        __redisSetError(c, REDIS_ERR_OOM, "Out of memory");
849:        redisContextConnectBindTcp(c, options->endpoint.tcp.ip,
853:        redisContextConnectUnix(c, options->endpoint.unix_socket,
859:        redisFree(c);
866:        redisContextSetTimeout(c, *options->command_timeout);
875:redisContext *redisConnect(const char *ip, int port) {
876:    redisOptions options = {0};
878:    return redisConnectWithOptions(&options);
881:redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {
882:    redisOptions options = {0};
885:    return redisConnectWithOptions(&options);
888:redisContext *redisConnectNonBlock(const char *ip, int port) {
889:    redisOptions options = {0};
892:    return redisConnectWithOptions(&options);
895:redisContext *redisConnectBindNonBlock(const char *ip, int port,
897:    redisOptions options = {0};
901:    return redisConnectWithOptions(&options);
904:redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
906:    redisOptions options = {0};
910:    return redisConnectWithOptions(&options);
913:redisContext *redisConnectUnix(const char *path) {
914:    redisOptions options = {0};
916:    return redisConnectWithOptions(&options);
919:redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {
920:    redisOptions options = {0};
923:    return redisConnectWithOptions(&options);
926:redisContext *redisConnectUnixNonBlock(const char *path) {
927:    redisOptions options = {0};
930:    return redisConnectWithOptions(&options);
933:redisContext *redisConnectFd(redisFD fd) {
934:    redisOptions options = {0};
937:    return redisConnectWithOptions(&options);
941:int redisSetTimeout(redisContext *c, const struct timeval tv) {
943:        return redisContextSetTimeout(c,tv);
947:int redisEnableKeepAliveWithInterval(redisContext *c, int interval) {
948:    return redisKeepAlive(c, interval);
952:int redisEnableKeepAlive(redisContext *c) {
953:    return redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL);
957:int redisSetTcpUserTimeout(redisContext *c, unsigned int timeout) {
958:    return redisContextSetTcpUserTimeout(c, timeout);
962:redisPushFn *redisSetPushCallback(redisContext *c, redisPushFn *fn) {
963:    redisPushFn *old = c->push_cb;
971: * After this function is called, you may use redisGetReplyFromReader to
973:int redisBufferRead(redisContext *c) {
985:    if (nread > 0 && redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
986:        __redisSetError(c, c->reader->err, c->reader->errstr);
1001:int redisBufferWrite(redisContext *c, int *done) {
1026:    __redisSetError(c, REDIS_ERR_OOM, "Out of memory");
1032:static int redisHandledPushReply(redisContext *c, void *reply) {
1033:    if (reply && c->push_cb && redisIsPushReply(reply)) {
1042:int redisGetReplyFromReader(redisContext *c, void **reply) {
1043:    if (redisReaderGetReply(c->reader, reply) == REDIS_ERR) {
1044:        __redisSetError(c,c->reader->err,c->reader->errstr);
1053: * redisGetReplyFromReader so as to not change its behavior. */
1054:static int redisNextInBandReplyFromReader(redisContext *c, void **reply) {
1056:        if (redisGetReplyFromReader(c, reply) == REDIS_ERR)
1058:    } while (redisHandledPushReply(c, *reply));
1063:int redisGetReply(redisContext *c, void **reply) {
1068:    if (redisNextInBandReplyFromReader(c,&aux) == REDIS_ERR)
1075:            if (redisBufferWrite(c,&wdone) == REDIS_ERR)
1081:            if (redisBufferRead(c) == REDIS_ERR)
1084:            if (redisNextInBandReplyFromReader(c,&aux) == REDIS_ERR)
1100:/* Helper function for the redisAppendCommand* family of functions.
1103: * is used, you need to call redisGetReply yourself to retrieve
1106:int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {
1111:        __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
1119:int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {
1121:    if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
1128:int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {
1132:    len = redisvFormatCommand(&cmd,format,ap);
1134:        __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
1137:        __redisSetError(c,REDIS_ERR_OTHER,"Invalid format string");
1141:    if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {
1150:int redisAppendCommand(redisContext *c, const char *format, ...) {
1155:    ret = redisvAppendCommand(c,format,ap);
1160:int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
1164:    len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
1166:        __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
1170:    if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {
1179:/* Helper function for the redisCommand* family of functions.
1190:static void *__redisBlockForReply(redisContext *c) {
1194:        if (redisGetReply(c,&reply) != REDIS_OK)
1201:void *redisvCommand(redisContext *c, const char *format, va_list ap) {
1202:    if (redisvAppendCommand(c,format,ap) != REDIS_OK)
1204:    return __redisBlockForReply(c);
1207:void *redisCommand(redisContext *c, const char *format, ...) {
1210:    void *reply = redisvCommand(c,format,ap);
1215:void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
1216:    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK)
1218:    return __redisBlockForReply(c);

deps/README.md
5:* **hiredis** is the official C client library for Redis. It is used by redis-cli, redis-benchmark and Redis Sentinel. It is part of the Redis official ecosystem but is developed externally from the Redis repository, so we just upgrade it as needed.
62:Hiredis
65:Hiredis is used by Sentinel, `valkey-cli` and `valkey-benchmark`. Like Valkey, uses the SDS string library, but not necessarily the same version. In order to avoid conflicts, this version has all SDS identifiers prefixed by `hi`.
67:1. `git subtree pull --prefix deps/hiredis https://github.com/redis/hiredis.git <version-tag> --squash`<br>

deps/hiredis/test.sh
3:REDIS_SERVER=${REDIS_SERVER:-redis-server}
13:# We need to enable the DEBUG command for redis-server >= 7.0.0
14:REDIS_MAJOR_VERSION="$(redis-server --version|awk -F'[^0-9]+' '{ print $2 }')"
20:PID_FILE=${tmpdir}/hiredis-test-redis.pid
21:SOCK_FILE=${tmpdir}/hiredis-test-redis.sock
34:        -subj '/CN=Hiredis Test CA' \
40:        -subj '/CN=Hiredis Test Cert' | \
55:    docker kill redis-test-server
65:cat > ${tmpdir}/redis.conf <<EOF
74:cat >> ${tmpdir}/redis.conf <<EOF
83:    cat >> ${tmpdir}/redis.conf <<EOF
92:cat ${tmpdir}/redis.conf
96:    docker run -d --rm --name redis-test-server \
101:        redis-server ${tmpdir}/redis.conf
103:    ${REDIS_SERVER} ${tmpdir}/redis.conf
112:${TEST_PREFIX:-} ./hiredis-test -h 127.0.0.1 -p ${REDIS_PORT} -s ${SOCK_FILE} ${SSL_TEST_ARGS} ${SKIPS_ARG}

deps/hiredis/hiredis_ssl.h
47:typedef struct redisSSLContext redisSSLContext;
50: * Initialization errors that redisCreateSSLContext() may return.
63:} redisSSLContextError;
66: * REDIS_SSL_VERIFY_PEER is used with redisCreateSSLContext().
84:} redisSSLOptions;
90:const char *redisSSLContextGetError(redisSSLContextError error);
99:int redisInitOpenSSL(void);
122:redisSSLContext *redisCreateSSLContext(const char *cacert_filename, const char *capath,
124:        const char *server_name, redisSSLContextError *error);
128:  * to initiate SSL connections. This is a more extensible version of redisCreateSSLContext().
135:redisSSLContext *redisCreateSSLContextWithOptions(redisSSLOptions *options,
136:        redisSSLContextError *error);
141:void redisFreeSSLContext(redisSSLContext *redis_ssl_ctx);
144: * Initiate SSL on an existing redisContext.
146: * This is similar to redisInitiateSSL() but does not require the caller
147: * to directly interact with OpenSSL, and instead uses a redisSSLContext
148: * previously created using redisCreateSSLContext().
151:int redisInitiateSSLWithContext(redisContext *c, redisSSLContext *redis_ssl_ctx);
157:int redisInitiateSSL(redisContext *c, struct ssl_st *ssl);

deps/hiredis/CHANGELOG.md
1:## [1.2.0](https://github.com/redis/hiredis/tree/v1.2.0) - (2023-06-04)
3:Announcing Hiredis v1.2.0 with with new adapters, and a great many bug fixes.
52:## [1.1.0](https://github.com/redis/hiredis/tree/v1.1.0) - (2022-11-15)
54:Announcing Hiredis v1.1.0 GA with better SSL convenience, new async adapters and a great many bug fixes.
56:**NOTE**:  Hiredis can now return `nan` in addition to `-inf` and `inf` when returning a `REDIS_REPLY_DOUBLE`.
61:  ([\#1133](https://github.com/redis/hiredis/pull/1133))
65:- Add an example that calls redisCommandArgv [@michael-grunder](https://github.com/michael-grunder)
66:  ([\#1140](https://github.com/redis/hiredis/pull/1140))
67:- fix flag reference [@pata00](https://github.com/pata00) ([\#1136](https://github.com/redis/hiredis/pull/1136))
68:- Make freeing a NULL redisAsyncContext a no op. [@michael-grunder](https://github.com/michael-grunder)
69:  ([\#1135](https://github.com/redis/hiredis/pull/1135))
70:- CI updates ([@bjosv](https://github.com/redis/bjosv) ([\#1139](https://github.com/redis/hiredis/pull/1139))
81:## [1.1.0-rc1](https://github.com/redis/hiredis/tree/v1.1.0-rc1) - (2022-11-06)
83:Announcing Hiredis v1.1.0-rc1, with better SSL convenience, new async adapters, and a great many bug fixes.
88:  ([\#1096](https://github.com/redis/hiredis/pull/1096))
89:- Add adapters/libhv [@ithewei](https://github.com/ithewei) ([\#904](https://github.com/redis/hiredis/pull/904))
90:- Add timeout support to libhv adapter. [@michael-grunder](https://github.com/michael-grunder) ([\#1109](https://github.com/redis/hiredis/pull/1109))
91:- set default SSL verification path [@adobeturchenko](https://github.com/adobeturchenko) ([\#928](https://github.com/redis/hiredis/pull/928))
92:- Introduce .close method for redisContextFuncs [@pizhenwei](https://github.com/pizhenwei) ([\#1094](https://github.com/redis/hiredis/pull/1094))
93:- Make it possible to set SSL verify mode [@stanhu](https://github.com/stanhu) ([\#1085](https://github.com/redis/hiredis/pull/1085))
94:- Polling adapter and example [@kristjanvalur](https://github.com/kristjanvalur) ([\#932](https://github.com/redis/hiredis/pull/932))
95:- Unsubscribe handling in async [@bjosv](https://github.com/bjosv) ([\#1047](https://github.com/redis/hiredis/pull/1047))
96:- Add timeout support for libuv adapter [@MichaelSuen-thePointer](https://github.com/@MichaelSuenthePointer) ([\#1016](https://github.com/redis/hiredis/pull/1016))
100:- Update for MinGW cross compile [@bit0fun](https://github.com/bit0fun) ([\#1127](https://github.com/redis/hiredis/pull/1127))
101:- fixed CPP build error with adapters/libhv.h [@mtdxc](https://github.com/mtdxc) ([\#1125](https://github.com/redis/hiredis/pull/1125))
104:  [@mtuleika-appcast](https://github.com/mtuleika-appcast) ([\#1106](https://github.com/redis/hiredis/pull/1106))
105:- Use a windows specific keepalive function. [@michael-grunder](https://github.com/michael-grunder) ([\#1104](https://github.com/redis/hiredis/pull/1104))
106:- Fix CMake config path on Linux. [@xkszltl](https://github.com/xkszltl) ([\#989](https://github.com/redis/hiredis/pull/989))
107:- Fix potential fault at createDoubleObject [@afcidk](https://github.com/afcidk) ([\#964](https://github.com/redis/hiredis/pull/964))
108:- Fix some undefined behavior [@jengab](https://github.com/jengab) ([\#1091](https://github.com/redis/hiredis/pull/1091))
109:- Copy OOM errors to redisAsyncContext when finding subscribe callback [@bjosv](https://github.com/bjosv) ([\#1090](https://github.com/redis/hiredis/pull/1090))
110:- Maintain backward compatibility with our onConnect callback. [@michael-grunder](https://github.com/michael-grunder) ([\#1087](https://github.com/redis/hiredis/pull/1087))
111:- Fix PUSH handler tests for Redis >= 7.0.5 [@michael-grunder](https://github.com/michael-grunder) ([\#1121](https://github.com/redis/hiredis/pull/1121))
112:- fix heap-buffer-overflow [@zhangtaoXT5](https://github.com/zhangtaoXT5) ([\#957](https://github.com/redis/hiredis/pull/957))
113:- Fix heap-buffer-overflow issue in redisvFormatCommad [@bjosv](https://github.com/bjosv) ([\#1097](https://github.com/redis/hiredis/pull/1097))
114:- Polling adapter requires sockcompat.h [@michael-grunder](https://github.com/michael-grunder) ([\#1095](https://github.com/redis/hiredis/pull/1095))
115:- Illumos test fixes, error message difference for bad hostname test. [@devnexen](https://github.com/devnexen) ([\#901](https://github.com/redis/hiredis/pull/901))
116:- Remove semicolon after do-while in \_EL\_CLEANUP [@sundb](https://github.com/sundb) ([\#905](https://github.com/redis/hiredis/pull/905))
117:- Stability: Support calling redisAsyncCommand and redisAsyncDisconnect from the onConnected callback [@kristjanvalur](https://github.com/kristjanvalur)
118:  ([\#931](https://github.com/redis/hiredis/pull/931))
119:- Fix async connect on Windows [@kristjanvalur](https://github.com/kristjanvalur) ([\#1073](https://github.com/redis/hiredis/pull/1073))
120:- Fix tests so they work for Redis 7.0 [@michael-grunder](https://github.com/michael-grunder) ([\#1072](https://github.com/redis/hiredis/pull/1072))
121:- Fix warnings on Win64 [@orgads](https://github.com/orgads) ([\#1058](https://github.com/redis/hiredis/pull/1058))
122:- Handle push notifications before or after reply. [@yossigo](https://github.com/yossigo) ([\#1062](https://github.com/redis/hiredis/pull/1062))
123:- Update hiredis sds with improvements found in redis [@bjosv](https://github.com/bjosv) ([\#1045](https://github.com/redis/hiredis/pull/1045))
124:- Avoid incorrect call to the previous reply's callback [@bjosv](https://github.com/bjosv) ([\#1040](https://github.com/redis/hiredis/pull/1040))
125:- fix building on AIX and SunOS [\#1031](https://github.com/redis/hiredis/pull/1031) ([@scddev](https://github.com/scddev))
126:- Allow sending commands after sending an unsubscribe [@bjosv](https://github.com/bjosv) ([\#1036](https://github.com/redis/hiredis/pull/1036))
127:- Correction for command timeout during pubsub [@bjosv](https://github.com/bjosv) ([\#1038](https://github.com/redis/hiredis/pull/1038))
128:- Fix adapters/libevent.h compilation for 64-bit Windows [@pbtummillo](https://github.com/pbtummillo) ([\#937](https://github.com/redis/hiredis/pull/937))
129:- Fix integer overflow when format command larger than 4GB [@sundb](https://github.com/sundb) ([\#1030](https://github.com/redis/hiredis/pull/1030))
130:- Handle array response during subscribe in RESP3 [@bjosv](https://github.com/bjosv) ([\#1014](https://github.com/redis/hiredis/pull/1014))
131:- Support PING while subscribing (RESP2) [@bjosv](https://github.com/bjosv) ([\#1027](https://github.com/redis/hiredis/pull/1027))
135:- CI fixes in preparation of release [@michael-grunder](https://github.com/michael-grunder) ([\#1130](https://github.com/redis/hiredis/pull/1130))
136:- Add do while(0) (protection for macros [@afcidk](https://github.com/afcidk) [\#959](https://github.com/redis/hiredis/pull/959))
137:- Fixup of PR734: Coverage of hiredis.c [@bjosv](https://github.com/bjosv) ([\#1124](https://github.com/redis/hiredis/pull/1124))
138:- CMake corrections for building on Windows [@bjosv](https://github.com/bjosv) ([\#1122](https://github.com/redis/hiredis/pull/1122))
139:- Install on windows fixes [@bjosv](https://github.com/bjosv) ([\#1117](https://github.com/redis/hiredis/pull/1117))
140:- Add libhv example to our standard Makefile [@michael-grunder](https://github.com/michael-grunder) ([\#1108](https://github.com/redis/hiredis/pull/1108))
141:- Additional include directory given by pkg-config [@bjosv](https://github.com/bjosv) ([\#1118](https://github.com/redis/hiredis/pull/1118))
142:- Use __attribute__ when building with Clang on Windows [@bjosv](https://github.com/bjosv) ([\#1115](https://github.com/redis/hiredis/pull/1115))
143:- Minor refactor [@michael-grunder](https://github.com/michael-grunder) ([\#1110](https://github.com/redis/hiredis/pull/1110))
144:- Fix pkgconfig result for hiredis_ssl [@bjosv](https://github.com/bjosv) ([\#1107](https://github.com/redis/hiredis/pull/1107))
145:- Update documentation to explain redisConnectWithOptions. [@michael-grunder](https://github.com/michael-grunder) ([\#1099](https://github.com/redis/hiredis/pull/1099))
146:- uvadapter: reduce number of uv_poll_start calls [@noxiouz](https://github.com/noxiouz) ([\#1098](https://github.com/redis/hiredis/pull/1098))
147:- Regression test for off-by-one parsing error [@bugwz](https://github.com/bugwz) ([\#1092](https://github.com/redis/hiredis/pull/1092))
148:- CMake: remove dict.c form hiredis_sources [@Lipraxde](https://github.com/Lipraxde) ([\#1055](https://github.com/redis/hiredis/pull/1055))
149:- Do store command timeout in the context for redisSetTimeout [@catterer](https://github.com/catterer) ([\#593](https://github.com/redis/hiredis/pull/593), [\#1093](https://github.com/redis/hiredis/pull/1093))
150:- Add GitHub Actions CI workflow for hiredis: Arm, Arm64, 386, windows. [@kristjanvalur](https://github.com/kristjanvalur) ([\#943](https://github.com/redis/hiredis/pull/943))
151:- CI: bump macOS runner version [@SukkaW](https://github.com/SukkaW) ([\#1079](https://github.com/redis/hiredis/pull/1079))
152:- Support for generating release notes [@chayim](https://github.com/chayim) ([\#1083](https://github.com/redis/hiredis/pull/1083))
153:- Improve example for SSL initialization in README.md [@stanhu](https://github.com/stanhu) ([\#1084](https://github.com/redis/hiredis/pull/1084))
154:- Fix README typos [@bjosv](https://github.com/bjosv) ([\#1080](https://github.com/redis/hiredis/pull/1080))
155:- fix cmake version [@smmir-cent](https://github.com/@smmircent) ([\#1050](https://github.com/redis/hiredis/pull/1050))
156:- Use the same name for static and shared libraries [@orgads](https://github.com/orgads) ([\#1057](https://github.com/redis/hiredis/pull/1057))
157:- Embed debug information in windows static .lib file [@kristjanvalur](https://github.com/kristjanvalur) ([\#1054](https://github.com/redis/hiredis/pull/1054))
158:- Improved async documentation [@kristjanvalur](https://github.com/kristjanvalur) ([\#1074](https://github.com/redis/hiredis/pull/1074))
159:- Use official repository for redis package. [@yossigo](https://github.com/yossigo) ([\#1061](https://github.com/redis/hiredis/pull/1061))
160:- Whitelist hiredis repo path in cygwin [@michael-grunder](https://github.com/michael-grunder) ([\#1063](https://github.com/redis/hiredis/pull/1063))
161:- CentOS 8 is EOL, switch to RockyLinux [@michael-grunder](https://github.com/michael-grunder) ([\#1046](https://github.com/redis/hiredis/pull/1046))
162:- CMakeLists.txt: allow building without a C++ compiler [@ffontaine](https://github.com/ffontaine) ([\#872](https://github.com/redis/hiredis/pull/872))
163:- Makefile: move SSL options into a block and refine rules [@pizhenwei](https://github.com/pizhenwei) ([\#997](https://github.com/redis/hiredis/pull/997))
164:- Update CMakeLists.txt for more portability [@EricDeng1001](https://github.com/EricDeng1001) ([\#1005](https://github.com/redis/hiredis/pull/1005))
165:- FreeBSD build fixes + CI [@michael-grunder](https://github.com/michael-grunder) ([\#1026](https://github.com/redis/hiredis/pull/1026))
166:- Add asynchronous test for pubsub using RESP3 [@bjosv](https://github.com/bjosv) ([\#1012](https://github.com/redis/hiredis/pull/1012))
167:- Trigger CI failure when Valgrind issues are found [@bjosv](https://github.com/bjosv) ([\#1011](https://github.com/redis/hiredis/pull/1011))
168:- Move to using make directly in Cygwin [@michael-grunder](https://github.com/michael-grunder) ([\#1020](https://github.com/redis/hiredis/pull/1020))
169:- Add asynchronous API tests [@bjosv](https://github.com/bjosv) ([\#1010](https://github.com/redis/hiredis/pull/1010))
170:- Correcting the build target `coverage` for enabled SSL [@bjosv](https://github.com/bjosv) ([\#1009](https://github.com/redis/hiredis/pull/1009))
171:- GH Actions: Run SSL tests during CI [@bjosv](https://github.com/bjosv) ([\#1008](https://github.com/redis/hiredis/pull/1008))
172:- GH: Actions - Add valgrind and CMake [@michael-grunder](https://github.com/michael-grunder) ([\#1004](https://github.com/redis/hiredis/pull/1004))
173:- Add Centos8 tests in GH Actions [@michael-grunder](https://github.com/michael-grunder) ([\#1001](https://github.com/redis/hiredis/pull/1001))
174:- We should run actions on PRs [@michael-grunder](https://github.com/michael-grunder) (([\#1000](https://github.com/redis/hiredis/pull/1000))
175:- Add Cygwin test in GitHub actions [@michael-grunder](https://github.com/michael-grunder) ([\#999](https://github.com/redis/hiredis/pull/999))
176:- Add Windows tests in GitHub actions [@michael-grunder](https://github.com/michael-grunder) ([\#996](https://github.com/redis/hiredis/pull/996))
177:- Switch to GitHub actions [@michael-grunder](https://github.com/michael-grunder) ([\#995](https://github.com/redis/hiredis/pull/995))
178:- Minor refactor of CVE-2021-32765 fix. [@michael-grunder](https://github.com/michael-grunder) ([\#993](https://github.com/redis/hiredis/pull/993))
179:- Remove extra comma from CMake var. [@xkszltl](https://github.com/xkszltl) ([\#988](https://github.com/redis/hiredis/pull/988))
180:- Add REDIS\_OPT\_PREFER\_UNSPEC [@michael-grunder](https://github.com/michael-grunder) ([\#1101](https://github.com/redis/hiredis/pull/1101))
217:## [1.0.2](https://github.com/redis/hiredis/tree/v1.0.2) - (2021-10-07)
219:Announcing Hiredis v1.0.2, which fixes CVE-2021-32765 but returns the SONAME to the correct value of `1.0.0`.
221:- [Revert SONAME bump](https://github.com/redis/hiredis/commit/d4e6f109a064690cde64765c654e679fea1d3548)
224:## [1.0.1](https://github.com/redis/hiredis/tree/v1.0.1) - (2021-10-04)
226:<span style="color:red">This release erroneously bumped the SONAME, please use [1.0.2](https://github.com/redis/hiredis/tree/v1.0.2)</span>
228:Announcing Hiredis v1.0.1, a security release fixing CVE-2021-32765
230:- Fix for [CVE-2021-32765](https://github.com/redis/hiredis/security/advisories/GHSA-hfm9-39pp-55p2)
231:  [commit](https://github.com/redis/hiredis/commit/76a7b10005c70babee357a7d0f2becf28ec7ed1e)
236:## [1.0.0](https://github.com/redis/hiredis/tree/v1.0.0) - (2020-08-03)
238:Announcing Hiredis v1.0.0, which adds support for RESP3, SSL connections, allocator injection, and better Windows support! :tada:
251:[Full Changelog](https://github.com/redis/hiredis/compare/v0.14.1...v1.0.0)
255:* `redisOptions` now has two timeout fields.  One for connecting, and one for commands.  If you're presently using `options->timeout` you will need to change it to use `options->connect_timeout`. (See [example](https://github.com/redis/hiredis/commit/38b5ae543f5c99eb4ccabbe277770fc6bc81226f#diff-86ba39d37aa829c8c82624cce4f049fbL36))
260:* `redisReplyObjectFunctions.createArray` now takes `size_t` for its length parameter.
264:  [\#697](https://github.com/redis/hiredis/pull/697),
265:  [\#805](https://github.com/redis/hiredis/pull/805),
266:  [\#819](https://github.com/redis/hiredis/pull/819),
267:  [\#841](https://github.com/redis/hiredis/pull/841)
270:  [\#645](https://github.com/redis/hiredis/pull/645),
271:  [\#699](https://github.com/redis/hiredis/pull/699),
272:  [\#702](https://github.com/redis/hiredis/pull/702),
273:  [\#708](https://github.com/redis/hiredis/pull/708),
274:  [\#711](https://github.com/redis/hiredis/pull/711),
275:  [\#821](https://github.com/redis/hiredis/pull/821),
276:  [more](https://github.com/redis/hiredis/pulls?q=is%3Apr+is%3Amerged+SSL)
279:  [\#800](https://github.com/redis/hiredis/pull/800)
282:  [\#652](https://github.com/redis/hiredis/pull/652),
283:  [\#663](https://github.com/redis/hiredis/pull/663)
286:  [\#839](https://github.com/redis/hiredis/pull/839),
287:  [\#829](https://github.com/redis/hiredis/pull/829)
289:- Add generic pointer and destructor to `redisContext` that users can use for context.
290:  [\#855](https://github.com/redis/hiredis/pull/855)
295:- Makefile does not install TLS libraries  [\#809](https://github.com/redis/hiredis/issues/809)
296:- redisConnectWithOptions should not set command timeout [\#722](https://github.com/redis/hiredis/issues/722), [\#829](https://github.com/redis/hiredis/pull/829) ([valentinogeron](https://github.com/valentinogeron))
297:- Fix integer overflow in `sdsrange` [\#827](https://github.com/redis/hiredis/issues/827)
298:- INFO & CLUSTER commands failed when using RESP3 [\#802](https://github.com/redis/hiredis/issues/802)
299:- Windows compatibility patches [\#687](https://github.com/redis/hiredis/issues/687), [\#838](https://github.com/redis/hiredis/issues/838), [\#842](https://github.com/redis/hiredis/issues/842)
300:- RESP3 PUSH messages incorrectly use pending callback [\#825](https://github.com/redis/hiredis/issues/825)
301:- Asynchronous PSUBSCRIBE command fails when using RESP3 [\#815](https://github.com/redis/hiredis/issues/815)
302:- New SSL API [\#804](https://github.com/redis/hiredis/issues/804), [\#813](https://github.com/redis/hiredis/issues/813)
303:- Hard-coded limit of nested reply depth [\#794](https://github.com/redis/hiredis/issues/794)
304:- Fix TCP_NODELAY in Windows/OSX [\#679](https://github.com/redis/hiredis/issues/679), [\#690](https://github.com/redis/hiredis/issues/690), [\#779](https://github.com/redis/hiredis/issues/779), [\#785](https://github.com/redis/hiredis/issues/785),
305:- Added timers to libev adapter.  [\#778](https://github.com/redis/hiredis/issues/778), [\#795](https://github.com/redis/hiredis/pull/795)
306:- Initialization discards const qualifier [\#777](https://github.com/redis/hiredis/issues/777)
307:- \[BUG\]\[MinGW64\] Error setting socket timeout  [\#775](https://github.com/redis/hiredis/issues/775)
308:- undefined reference to hi_malloc [\#769](https://github.com/redis/hiredis/issues/769)
309:- hiredis pkg-config file incorrectly ignores multiarch libdir spec'n [\#767](https://github.com/redis/hiredis/issues/767)
310:- Don't use -G to build shared object on Solaris [\#757](https://github.com/redis/hiredis/issues/757)
311:- error when make USE\_SSL=1 [\#748](https://github.com/redis/hiredis/issues/748)
312:- Allow to change SSL Mode [\#646](https://github.com/redis/hiredis/issues/646)
313:- hiredis/adapters/libevent.h memleak [\#618](https://github.com/redis/hiredis/issues/618)
314:- redisLibuvPoll crash when server closes the connetion [\#545](https://github.com/redis/hiredis/issues/545)
315:- about redisAsyncDisconnect question [\#518](https://github.com/redis/hiredis/issues/518)
316:- hiredis adapters libuv error for help [\#508](https://github.com/redis/hiredis/issues/508)
317:- API/ABI changes analysis [\#506](https://github.com/redis/hiredis/issues/506)
318:- Memory leak patch in Redis [\#502](https://github.com/redis/hiredis/issues/502)
319:- Remove the depth limitation [\#421](https://github.com/redis/hiredis/issues/421)
323:- Move SSL management to a distinct private pointer [\#855](https://github.com/redis/hiredis/pull/855) ([michael-grunder](https://github.com/michael-grunder))
324:- Move include to sockcompat.h to maintain style [\#850](https://github.com/redis/hiredis/pull/850) ([michael-grunder](https://github.com/michael-grunder))
325:- Remove erroneous tag and add license to push example [\#849](https://github.com/redis/hiredis/pull/849) ([michael-grunder](https://github.com/michael-grunder))
326:- fix windows compiling with mingw [\#848](https://github.com/redis/hiredis/pull/848) ([rmalizia44](https://github.com/rmalizia44))
327:- Some Windows quality of life improvements. [\#846](https://github.com/redis/hiredis/pull/846) ([michael-grunder](https://github.com/michael-grunder))
328:- Use \_WIN32 define instead of WIN32 [\#845](https://github.com/redis/hiredis/pull/845) ([michael-grunder](https://github.com/michael-grunder))
329:- Non Linux CI fixes [\#844](https://github.com/redis/hiredis/pull/844) ([michael-grunder](https://github.com/michael-grunder))
330:- Resp3 oob push support [\#841](https://github.com/redis/hiredis/pull/841) ([michael-grunder](https://github.com/michael-grunder))
331:- fix \#785: defer TCP\_NODELAY in async tcp connections [\#836](https://github.com/redis/hiredis/pull/836) ([OmriSteiner](https://github.com/OmriSteiner))
332:- sdsrange overflow fix [\#830](https://github.com/redis/hiredis/pull/830) ([michael-grunder](https://github.com/michael-grunder))
333:- Use explicit pointer casting for c++ compatibility [\#826](https://github.com/redis/hiredis/pull/826) ([aureus1](https://github.com/aureus1))
334:- Document allocator injection and completeness fix in test.c [\#824](https://github.com/redis/hiredis/pull/824) ([michael-grunder](https://github.com/michael-grunder))
335:- Use unique names for allocator struct members [\#823](https://github.com/redis/hiredis/pull/823) ([michael-grunder](https://github.com/michael-grunder))
336:- New SSL API to replace redisSecureConnection\(\). [\#821](https://github.com/redis/hiredis/pull/821) ([yossigo](https://github.com/yossigo))
337:- Add logic to handle RESP3 push messages [\#819](https://github.com/redis/hiredis/pull/819) ([michael-grunder](https://github.com/michael-grunder))
338:- Use standrad isxdigit instead of custom helper function. [\#814](https://github.com/redis/hiredis/pull/814) ([tryfinally](https://github.com/tryfinally))
339:- Fix missing SSL build/install options. [\#812](https://github.com/redis/hiredis/pull/812) ([yossigo](https://github.com/yossigo))
340:- Add link to ABI tracker [\#808](https://github.com/redis/hiredis/pull/808) ([michael-grunder](https://github.com/michael-grunder))
341:- Resp3 verbatim string support [\#805](https://github.com/redis/hiredis/pull/805) ([michael-grunder](https://github.com/michael-grunder))
342:- Allow users to replace allocator and handle OOM everywhere. [\#800](https://github.com/redis/hiredis/pull/800) ([michael-grunder](https://github.com/michael-grunder))
343:- Remove nested depth limitation. [\#797](https://github.com/redis/hiredis/pull/797) ([michael-grunder](https://github.com/michael-grunder))
344:- Attempt to fix compilation on Solaris [\#796](https://github.com/redis/hiredis/pull/796) ([michael-grunder](https://github.com/michael-grunder))
345:- Support timeouts in libev adapater [\#795](https://github.com/redis/hiredis/pull/795) ([michael-grunder](https://github.com/michael-grunder))
346:- Fix pkgconfig when installing to a custom lib dir [\#793](https://github.com/redis/hiredis/pull/793) ([michael-grunder](https://github.com/michael-grunder))
347:- Fix USE\_SSL=1 make/cmake on OSX and CMake tests [\#789](https://github.com/redis/hiredis/pull/789) ([michael-grunder](https://github.com/michael-grunder))
348:- Use correct libuv call on Windows [\#784](https://github.com/redis/hiredis/pull/784) ([michael-grunder](https://github.com/michael-grunder))
349:- Added CMake package config and fixed hiredis\_ssl on Windows [\#783](https://github.com/redis/hiredis/pull/783) ([michael-grunder](https://github.com/michael-grunder))
350:- CMake: Set hiredis\_ssl shared object version. [\#780](https://github.com/redis/hiredis/pull/780) ([yossigo](https://github.com/yossigo))
351:- Win32 tests and timeout fix [\#776](https://github.com/redis/hiredis/pull/776) ([michael-grunder](https://github.com/michael-grunder))
352:- Provides an optional cleanup callback for async data. [\#768](https://github.com/redis/hiredis/pull/768) ([heronr](https://github.com/heronr))
353:- Housekeeping fixes [\#764](https://github.com/redis/hiredis/pull/764) ([michael-grunder](https://github.com/michael-grunder))
354:- install alloc.h [\#756](https://github.com/redis/hiredis/pull/756) ([ch1aki](https://github.com/ch1aki))
355:- fix spelling mistakes [\#746](https://github.com/redis/hiredis/pull/746) ([ShooterIT](https://github.com/ShooterIT))
356:- Free the reply in redisGetReply when passed NULL [\#741](https://github.com/redis/hiredis/pull/741) ([michael-grunder](https://github.com/michael-grunder))
357:- Fix dead code in sslLogCallback relating to should\_log variable. [\#737](https://github.com/redis/hiredis/pull/737) ([natoscott](https://github.com/natoscott))
358:- Fix typo in dict.c. [\#731](https://github.com/redis/hiredis/pull/731) ([Kevin-Xi](https://github.com/Kevin-Xi))
359:- Adding an option to DISABLE\_TESTS [\#727](https://github.com/redis/hiredis/pull/727) ([pbotros](https://github.com/pbotros))
360:- Update README with SSL support. [\#720](https://github.com/redis/hiredis/pull/720) ([yossigo](https://github.com/yossigo))
361:- Fixes leaks in unit tests [\#715](https://github.com/redis/hiredis/pull/715) ([michael-grunder](https://github.com/michael-grunder))
362:- SSL Tests [\#711](https://github.com/redis/hiredis/pull/711) ([yossigo](https://github.com/yossigo))
363:- SSL Reorganization [\#708](https://github.com/redis/hiredis/pull/708) ([yossigo](https://github.com/yossigo))
364:- Fix MSVC build. [\#706](https://github.com/redis/hiredis/pull/706) ([yossigo](https://github.com/yossigo))
365:- SSL: Properly report SSL\_connect\(\) errors. [\#702](https://github.com/redis/hiredis/pull/702) ([yossigo](https://github.com/yossigo))
366:- Silent SSL trace to stdout by default. [\#699](https://github.com/redis/hiredis/pull/699) ([yossigo](https://github.com/yossigo))
367:- Port RESP3 support from Redis. [\#697](https://github.com/redis/hiredis/pull/697) ([yossigo](https://github.com/yossigo))
368:- Removed whitespace before newline [\#691](https://github.com/redis/hiredis/pull/691) ([Miniwoffer](https://github.com/Miniwoffer))
369:- Add install adapters header files [\#688](https://github.com/redis/hiredis/pull/688) ([kevin1018](https://github.com/kevin1018))
370:- Remove unnecessary null check before free [\#684](https://github.com/redis/hiredis/pull/684) ([qlyoung](https://github.com/qlyoung))
371:- redisReaderGetReply leak memory [\#671](https://github.com/redis/hiredis/pull/671) ([movebean](https://github.com/movebean))
372:- fix timeout code in windows [\#670](https://github.com/redis/hiredis/pull/670) ([jman-krafton](https://github.com/jman-krafton))
373:- test: fix errstr matching for musl libc [\#665](https://github.com/redis/hiredis/pull/665) ([ghost](https://github.com/ghost))
374:- Windows: MinGW fixes and Windows Travis builders [\#663](https://github.com/redis/hiredis/pull/663) ([mbitsnbites](https://github.com/mbitsnbites))
375:- The setsockopt and getsockopt API diffs from BSD socket and WSA one [\#662](https://github.com/redis/hiredis/pull/662) ([dragonation](https://github.com/dragonation))
376:- Fix Compile Error On Windows \(Visual Studio\) [\#658](https://github.com/redis/hiredis/pull/658) ([jinjiazhang](https://github.com/jinjiazhang))
377:- Fix NXDOMAIN test case [\#653](https://github.com/redis/hiredis/pull/653) ([michael-grunder](https://github.com/michael-grunder))
378:- Add MinGW support [\#652](https://github.com/redis/hiredis/pull/652) ([mbitsnbites](https://github.com/mbitsnbites))
379:- SSL Support [\#645](https://github.com/redis/hiredis/pull/645) ([mnunberg](https://github.com/mnunberg))
380:- Fix Invalid argument after redisAsyncConnectUnix [\#644](https://github.com/redis/hiredis/pull/644) ([codehz](https://github.com/codehz))
381:- Makefile: use predefined AR [\#632](https://github.com/redis/hiredis/pull/632) ([Mic92](https://github.com/Mic92))
382:- FreeBSD  build fix [\#628](https://github.com/redis/hiredis/pull/628) ([devnexen](https://github.com/devnexen))
383:- Fix errors not propagating properly with libuv.h. [\#624](https://github.com/redis/hiredis/pull/624) ([yossigo](https://github.com/yossigo))
384:- Update README.md [\#621](https://github.com/redis/hiredis/pull/621) ([Crunsher](https://github.com/Crunsher))
385:- Fix redisBufferRead documentation [\#620](https://github.com/redis/hiredis/pull/620) ([hacst](https://github.com/hacst))
386:- Add CPPFLAGS to REAL\_CFLAGS [\#614](https://github.com/redis/hiredis/pull/614) ([thomaslee](https://github.com/thomaslee))
387:- Update createArray to take size\_t [\#597](https://github.com/redis/hiredis/pull/597) ([justinbrewer](https://github.com/justinbrewer))
388:- fix common realloc mistake and add null check more [\#580](https://github.com/redis/hiredis/pull/580) ([charsyam](https://github.com/charsyam))
389:- Proper error reporting for connect failures [\#578](https://github.com/redis/hiredis/pull/578) ([mnunberg](https://github.com/mnunberg))
393:## [1.0.0-rc1](https://github.com/redis/hiredis/tree/v1.0.0-rc1) - (2020-07-29)
404:* Change `redisReply.len` to `size_t`, as it denotes the the size of a string
421:* Don't send negative values to `__redisAsyncCommand` (Frederik Deweerdt [706129])
425:* Keep track of errno in `__redisSetErrorFromErrno()` as snprintf may use it (Jin Qing [25cd88])
435:* Use proper format specifier in redisFormatSdsCommandArgv (Paulino Huerta, Jan-Erik Rediger [360a06, 8655a6])
442:* Import latest upstream sds. This breaks applications that are linked against the old hiredis v0.13
444:* Make hiredis compile in Cygwin on Windows, now CI-tested
455:| redisReplyReaderCreate      | redisReaderCreate      |
456:| redisReplyReaderCreate      | redisReaderCreate      |
457:| redisReplyReaderFree        | redisReaderFree        |
458:| redisReplyReaderFeed        | redisReaderFeed        |
459:| redisReplyReaderGetReply    | redisReaderGetReply    |
460:| redisReplyReaderSetPrivdata | redisReaderSetPrivdata |
461:| redisReplyReaderGetObject   | redisReaderGetObject   |
462:| redisReplyReaderGetError    | redisReaderGetError    |
497:Other non-C99 code can now use hiredis as usual again.
512:* Implement a reconnect method for the client context, this changes the structure of `redisContext` (Aaron Bedra)
533:* Add redisConnectFd() and redisFreeKeepFd()
539:* Improve redisAppendCommandArgv performance 2.5x
543:* Fix redisvFormatCommand format parsing

deps/hiredis/read.h
76:typedef struct redisReadTask {
81:    struct redisReadTask *parent; /* parent task */
83:} redisReadTask;
85:typedef struct redisReplyObjectFunctions {
86:    void *(*createString)(const redisReadTask*, char*, size_t);
87:    void *(*createArray)(const redisReadTask*, size_t);
88:    void *(*createInteger)(const redisReadTask*, long long);
89:    void *(*createDouble)(const redisReadTask*, double, char*, size_t);
90:    void *(*createNil)(const redisReadTask*);
91:    void *(*createBool)(const redisReadTask*, int);
93:} redisReplyObjectFunctions;
95:typedef struct redisReader {
105:    redisReadTask **task;
111:    redisReplyObjectFunctions *fn;
113:} redisReader;
116:redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn);
117:void redisReaderFree(redisReader *r);
118:int redisReaderFeed(redisReader *r, const char *buf, size_t len);
119:int redisReaderGetReply(redisReader *r, void **reply);
121:#define redisReaderSetPrivdata(_r, _p) (int)(((redisReader*)(_r))->privdata = (_p))
122:#define redisReaderGetObject(_r) (((redisReader*)(_r))->reply)
123:#define redisReaderGetError(_r) (((redisReader*)(_r))->errstr)

deps/hiredis/sockcompat.h
75:int win32_redisKeepAlive(SOCKET sockfd, int interval_ms);

deps/hiredis/hiredis-config.cmake.in
3:set_and_check(hiredis_INCLUDEDIR "@PACKAGE_INCLUDE_INSTALL_DIR@")
5:IF (NOT TARGET hiredis::@hiredis_export_name@)
6:	INCLUDE(${CMAKE_CURRENT_LIST_DIR}/hiredis-targets.cmake)
9:SET(hiredis_LIBRARIES hiredis::@hiredis_export_name@)
10:SET(hiredis_INCLUDE_DIRS ${hiredis_INCLUDEDIR})
12:check_required_components(hiredis)

deps/hiredis/hiredis_ssl.pc.in
6:pkgincludedir=${includedir}/hiredis
8:Name: hiredis_ssl
9:Description: SSL Support for hiredis.
11:Requires: hiredis
12:Libs: -L${libdir} -lhiredis_ssl

deps/hiredis/test.c
16:#include "hiredis.h"
20:#include "hiredis_ssl.h"
70:redisSSLContext *_ssl_ctx = NULL;
108:#define REDIS_VERSION_FIELD "redis_version:"
109:void get_redis_version(redisContext *c, int *majorptr, int *minorptr) {
110:    redisReply *reply;
114:    reply = redisCommand(c, "INFO");
144:static redisContext *select_database(redisContext *c) {
145:    redisReply *reply;
148:    reply = redisCommand(c,"SELECT 9");
153:    reply = redisCommand(c,"DBSIZE");
167:static void send_hello(redisContext *c, int version) {
168:    redisReply *reply;
171:    reply = redisCommand(c, "HELLO %d", version);
178:static void send_client_tracking(redisContext *c, const char *str) {
179:    redisReply *reply;
181:    reply = redisCommand(c, "CLIENT TRACKING %s", str);
186:static int disconnect(redisContext *c, int keep_fd) {
187:    redisReply *reply;
190:    reply = redisCommand(c,"SELECT 9");
193:    reply = redisCommand(c,"FLUSHDB");
199:        return redisFreeKeepFd(c);
200:    redisFree(c);
204:static void do_ssl_handshake(redisContext *c) {
206:    redisInitiateSSLWithContext(c, _ssl_ctx);
209:        redisFree(c);
217:static redisContext *do_connect(struct config config) {
218:    redisContext *c = NULL;
221:        c = redisConnect(config.tcp.host, config.tcp.port);
223:        c = redisConnect(config.ssl.host, config.ssl.port);
225:        c = redisConnectUnix(config.unix_sock.path);
228:        redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);
232:            c = redisConnectFd(fd);
239:        printf("Connection error: can't allocate redis context\n");
243:        redisFree(c);
254:static void do_reconnect(redisContext *c, struct config config) {
255:    redisReconnect(c);
267:    len = redisFormatCommand(&cmd,"SET foo bar");
273:    len = redisFormatCommand(&cmd,"SET %s %s","foo","bar");
279:    len = redisFormatCommand(&cmd,"SET %s %s","foo","");
285:    len = redisFormatCommand(&cmd,"SET %s %s","","foo");
291:    len = redisFormatCommand(&cmd,"SET %b %b","foo",(size_t)3,"b\0r",(size_t)3);
297:    len = redisFormatCommand(&cmd,"SET %b %b","foo",(size_t)3,"",(size_t)0);
303:    len = redisFormatCommand(&cmd,"SET %% %%");
314:    len = redisFormatCommand(&cmd,"key:%08" fmt " str:%s", value, "hello");               \
323:    len = redisFormatCommand(&cmd,"key:%08.3f str:%s", value, "hello");                   \
343:    len = redisFormatCommand(&cmd,"key:%08p %b",(void*)1234,"foo",(size_t)3);
347:    len = redisFormatCommand(&cmd,"%-");
358:    len = redisFormatCommandArgv(&cmd,argc,argv,NULL);
364:    len = redisFormatCommandArgv(&cmd,argc,argv,lens);
373:    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);
380:    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);
387:    redisContext *c;
388:    redisReply *reply;
396:    len = redisFormatCommand(&cmd, "SET foo bar");
398:    test_cond(redisAppendFormattedCommand(c, cmd, len) == REDIS_OK);
400:    assert(redisGetReply(c, (void*)&reply) == REDIS_OK);
409:    redisContext *c;
414:    test_cond(redisEnableKeepAlive(c) == REDIS_OK);
418:    test_cond(redisSetTcpUserTimeout(c, 100) == REDIS_OK);
421:    test_cond(redisSetTcpUserTimeout(c, 100) == REDIS_ERR && c->err == REDIS_ERR_IO);
424:    redisFree(c);
428:    redisReader *reader;
434:    reader = redisReaderCreate();
435:    redisReaderFeed(reader,(char*)"@foo\r\n",6);
436:    ret = redisReaderGetReply(reader,NULL);
439:    redisReaderFree(reader);
444:    reader = redisReaderCreate();
445:    redisReaderFeed(reader,(char*)"*2\r\n",4);
446:    redisReaderFeed(reader,(char*)"$5\r\nhello\r\n",11);
447:    redisReaderFeed(reader,(char*)"@foo\r\n",6);
448:    ret = redisReaderGetReply(reader,NULL);
451:    redisReaderFree(reader);
453:    reader = redisReaderCreate();
456:        redisReaderFeed(reader,(char*)"*1\r\n", 4);
458:    redisReaderFeed(reader,(char*)"$6\r\nLOLWUT\r\n",12);
459:    ret = redisReaderGetReply(reader,&reply);
462:        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&
463:        ((redisReply*)reply)->elements == 1);
467:        assert(reply != NULL && ((redisReply*)reply)->type == REDIS_REPLY_ARRAY);
468:        reply = ((redisReply*)reply)->element[0];
470:    test_cond(((redisReply*)reply)->type == REDIS_REPLY_STRING &&
471:        !memcmp(((redisReply*)reply)->str, "LOLWUT", 6));
473:    redisReaderFree(reader);
476:    reader = redisReaderCreate();
477:    redisReaderFeed(reader, ":9223372036854775807\r\n",22);
478:    ret = redisReaderGetReply(reader,&reply);
480:            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&
481:            ((redisReply*)reply)->integer == LLONG_MAX);
483:    redisReaderFree(reader);
486:    reader = redisReaderCreate();
487:    redisReaderFeed(reader, ":9223372036854775808\r\n",22);
488:    ret = redisReaderGetReply(reader,&reply);
492:    redisReaderFree(reader);
495:    reader = redisReaderCreate();
496:    redisReaderFeed(reader, ":-9223372036854775808\r\n",23);
497:    ret = redisReaderGetReply(reader,&reply);
499:            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&
500:            ((redisReply*)reply)->integer == LLONG_MIN);
502:    redisReaderFree(reader);
505:    reader = redisReaderCreate();
506:    redisReaderFeed(reader, ":-9223372036854775809\r\n",23);
507:    ret = redisReaderGetReply(reader,&reply);
511:    redisReaderFree(reader);
514:    reader = redisReaderCreate();
515:    redisReaderFeed(reader, "*-2\r\n+asdf\r\n",12);
516:    ret = redisReaderGetReply(reader,&reply);
520:    redisReaderFree(reader);
523:    reader = redisReaderCreate();
524:    redisReaderFeed(reader, "$-2\r\nasdf\r\n",11);
525:    ret = redisReaderGetReply(reader,&reply);
529:    redisReaderFree(reader);
532:    reader = redisReaderCreate();
534:    redisReaderFeed(reader, "*1025\r\n", 7);
535:    ret = redisReaderGetReply(reader,&reply);
539:    redisReaderFree(reader);
547:    reader = redisReaderCreate();
549:    redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));
550:    ret = redisReaderGetReply(reader,&reply);
553:    redisReaderFree(reader);
557:    reader = redisReaderCreate();
558:    redisReaderFeed(reader, "*9223372036854775807\r\n+asdf\r\n",29);
559:    ret = redisReaderGetReply(reader,&reply);
563:    redisReaderFree(reader);
566:    reader = redisReaderCreate();
567:    redisReaderFeed(reader, "$9223372036854775807\r\nasdf\r\n",28);
568:    ret = redisReaderGetReply(reader,&reply);
572:    redisReaderFree(reader);
576:    reader = redisReaderCreate();
578:    redisReaderFeed(reader,(char*)"+OK\r\n",5);
579:    ret = redisReaderGetReply(reader,&reply);
581:    redisReaderFree(reader);
584:    reader = redisReaderCreate();
586:    redisReaderFeed(reader,(char*)"+OK\r",4);
587:    ret = redisReaderGetReply(reader,&reply);
589:    redisReaderFeed(reader,(char*)"\n",1);
590:    ret = redisReaderGetReply(reader,&reply);
592:    redisReaderFree(reader);
595:    reader = redisReaderCreate();
597:    redisReaderFeed(reader,(char*)"x",1);
598:    ret = redisReaderGetReply(reader,&reply);
600:    ret = redisReaderGetReply(reader,&reply);
602:    redisReaderFree(reader);
605:    reader = redisReaderCreate();
606:    redisReaderFeed(reader,(char*)"*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$", 25);
607:    ret = redisReaderGetReply(reader,&reply);
609:    redisReaderFeed(reader,(char*)"3\r\nval\r\n", 8);
610:    ret = redisReaderGetReply(reader,&reply);
612:        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&
613:        ((redisReply*)reply)->elements == 3);
615:    redisReaderFree(reader);
619:    reader = redisReaderCreate();
620:    redisReaderFeed(reader,(char*)"*0\r\n",4);
621:    ret = redisReaderGetReply(reader,&reply);
623:        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&
624:        ((redisReply*)reply)->elements == 0);
626:    redisReaderFree(reader);
630:    reader = redisReaderCreate();
631:    redisReaderFeed(reader,(char*)"=10\r\ntxt:LOLWUT\r\n",17);
632:    ret = redisReaderGetReply(reader,&reply);
634:        ((redisReply*)reply)->type == REDIS_REPLY_VERB &&
635:         !memcmp(((redisReply*)reply)->str,"LOLWUT", 6));
637:    redisReaderFree(reader);
641:    reader = redisReaderCreate();
642:    redisReaderFeed(reader,(char*)">2\r\n$6\r\nLOLWUT\r\n:42\r\n",21);
643:    ret = redisReaderGetReply(reader,&reply);
645:        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&
646:        ((redisReply*)reply)->elements == 2 &&
647:        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&
648:        !memcmp(((redisReply*)reply)->element[0]->str,"LOLWUT",6) &&
649:        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&
650:        ((redisReply*)reply)->element[1]->integer == 42);
652:    redisReaderFree(reader);
655:    reader = redisReaderCreate();
656:    redisReaderFeed(reader, ",3.14159265358979323846\r\n",25);
657:    ret = redisReaderGetReply(reader,&reply);
659:              ((redisReply*)reply)->type == REDIS_REPLY_DOUBLE &&
660:              fabs(((redisReply*)reply)->dval - 3.14159265358979323846) < 0.00000001 &&
661:              ((redisReply*)reply)->len == 22 &&
662:              strcmp(((redisReply*)reply)->str, "3.14159265358979323846") == 0);
664:    redisReaderFree(reader);
667:    reader = redisReaderCreate();
668:    redisReaderFeed(reader, ",3.14159\000265358979323846\r\n",26);
669:    ret = redisReaderGetReply(reader,&reply);
673:    redisReaderFree(reader);
676:    reader = redisReaderCreate();
677:    redisReaderFeed(reader, ",inf\r\n",6);
678:    ret = redisReaderGetReply(reader,&reply);
680:              ((redisReply*)reply)->type == REDIS_REPLY_DOUBLE &&
681:              isinf(((redisReply*)reply)->dval) &&
682:              ((redisReply*)reply)->dval > 0);
684:    redisReaderFree(reader);
687:    reader = redisReaderCreate();
688:    redisReaderFeed(reader, ",nan\r\n",6);
689:    ret = redisReaderGetReply(reader,&reply);
691:              ((redisReply*)reply)->type == REDIS_REPLY_DOUBLE &&
692:              isnan(((redisReply*)reply)->dval));
694:    redisReaderFree(reader);
697:    reader = redisReaderCreate();
698:    redisReaderFeed(reader, ",-nan\r\n", 7);
699:    ret = redisReaderGetReply(reader, &reply);
701:              ((redisReply*)reply)->type == REDIS_REPLY_DOUBLE &&
702:              isnan(((redisReply*)reply)->dval));
704:    redisReaderFree(reader);
707:    reader = redisReaderCreate();
708:    redisReaderFeed(reader, "_\r\n",3);
709:    ret = redisReaderGetReply(reader,&reply);
711:              ((redisReply*)reply)->type == REDIS_REPLY_NIL);
713:    redisReaderFree(reader);
716:    reader = redisReaderCreate();
717:    redisReaderFeed(reader, "_nil\r\n",6);
718:    ret = redisReaderGetReply(reader,&reply);
722:    redisReaderFree(reader);
725:    reader = redisReaderCreate();
726:    redisReaderFeed(reader, "#t\r\n",4);
727:    ret = redisReaderGetReply(reader,&reply);
729:              ((redisReply*)reply)->type == REDIS_REPLY_BOOL &&
730:              ((redisReply*)reply)->integer);
732:    redisReaderFree(reader);
735:    reader = redisReaderCreate();
736:    redisReaderFeed(reader, "#f\r\n",4);
737:    ret = redisReaderGetReply(reader,&reply);
739:              ((redisReply*)reply)->type == REDIS_REPLY_BOOL &&
740:              !((redisReply*)reply)->integer);
742:    redisReaderFree(reader);
745:    reader = redisReaderCreate();
746:    redisReaderFeed(reader, "#foobar\r\n",9);
747:    ret = redisReaderGetReply(reader,&reply);
751:    redisReaderFree(reader);
754:    reader = redisReaderCreate();
755:    redisReaderFeed(reader, "%2\r\n+first\r\n:123\r\n$6\r\nsecond\r\n#t\r\n",34);
756:    ret = redisReaderGetReply(reader,&reply);
758:        ((redisReply*)reply)->type == REDIS_REPLY_MAP &&
759:        ((redisReply*)reply)->elements == 4 &&
760:        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STATUS &&
761:        ((redisReply*)reply)->element[0]->len == 5 &&
762:        !strcmp(((redisReply*)reply)->element[0]->str,"first") &&
763:        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&
764:        ((redisReply*)reply)->element[1]->integer == 123 &&
765:        ((redisReply*)reply)->element[2]->type == REDIS_REPLY_STRING &&
766:        ((redisReply*)reply)->element[2]->len == 6 &&
767:        !strcmp(((redisReply*)reply)->element[2]->str,"second") &&
768:        ((redisReply*)reply)->element[3]->type == REDIS_REPLY_BOOL &&
769:        ((redisReply*)reply)->element[3]->integer);
771:    redisReaderFree(reader);
774:    reader = redisReaderCreate();
775:    redisReaderFeed(reader, "~5\r\n+orange\r\n$5\r\napple\r\n#f\r\n:100\r\n:999\r\n",40);
776:    ret = redisReaderGetReply(reader,&reply);
778:        ((redisReply*)reply)->type == REDIS_REPLY_SET &&
779:        ((redisReply*)reply)->elements == 5 &&
780:        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STATUS &&
781:        ((redisReply*)reply)->element[0]->len == 6 &&
782:        !strcmp(((redisReply*)reply)->element[0]->str,"orange") &&
783:        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_STRING &&
784:        ((redisReply*)reply)->element[1]->len == 5 &&
785:        !strcmp(((redisReply*)reply)->element[1]->str,"apple") &&
786:        ((redisReply*)reply)->element[2]->type == REDIS_REPLY_BOOL &&
787:        !((redisReply*)reply)->element[2]->integer &&
788:        ((redisReply*)reply)->element[3]->type == REDIS_REPLY_INTEGER &&
789:        ((redisReply*)reply)->element[3]->integer == 100 &&
790:        ((redisReply*)reply)->element[4]->type == REDIS_REPLY_INTEGER &&
791:        ((redisReply*)reply)->element[4]->integer == 999);
793:    redisReaderFree(reader);
796:    reader = redisReaderCreate();
797:    redisReaderFeed(reader,"(3492890328409238509324850943850943825024385\r\n",46);
798:    ret = redisReaderGetReply(reader,&reply);
800:        ((redisReply*)reply)->type == REDIS_REPLY_BIGNUM &&
801:        ((redisReply*)reply)->len == 43 &&
802:        !strcmp(((redisReply*)reply)->str,"3492890328409238509324850943850943825024385"));
804:    redisReaderFree(reader);
807:    reader = redisReaderCreate();
808:    redisReaderFeed(reader, "*1\r\n,3.14159265358979323846\r\n",31);
809:    ret = redisReaderGetReply(reader,&reply);
811:        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&
812:        ((redisReply*)reply)->elements == 1 &&
813:        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_DOUBLE &&
814:        fabs(((redisReply*)reply)->element[0]->dval - 3.14159265358979323846) < 0.00000001 &&
815:        ((redisReply*)reply)->element[0]->len == 22 &&
816:        strcmp(((redisReply*)reply)->element[0]->str, "3.14159265358979323846") == 0);
818:    redisReaderFree(reader);
822:    void *redisCtx = NULL;
825:    test("Don't fail when redisFree is passed a NULL value: ");
826:    redisFree(redisCtx);
827:    test_cond(redisCtx == NULL);
861:    hiredisAllocFuncs ha = {
869:    // Override hiredis allocators
870:    hiredisSetAllocators(&ha);
872:    test("redisContext uses injected allocators: ");
873:    redisContext *c = redisConnect("localhost", 6379);
876:    test("redisReader uses injected allocators: ");
877:    redisReader *reader = redisReaderCreate();
880:    /* Make sure hiredis itself protects against a non-overflow checking calloc */
881:    test("hiredis calloc wrapper protects against overflow: ");
883:    hiredisSetAllocators(&ha);
888:    hiredisResetAllocators();
895:    redisContext *c;
902:        c = redisConnect(HIREDIS_BAD_DOMAIN, 6379);
915:        redisFree(c);
922:    redisOptions opt = {0};
926:    c = redisConnect((char*)"localhost", 1);
929:    redisFree(c);
937:    c = redisConnectWithOptions(&opt);
940:    redisFree(c);
943:    c = redisConnectUnix((char*)"/tmp/idontexist.sock");
945:    redisFree(c);
952:    redisReply *reply = r, *payload;
970:/* Dummy function just to test setting a callback with redisOptions */
971:void push_handler_async(redisAsyncContext *ac, void *reply) {
976:static void test_resp3_push_handler(redisContext *c) {
978:    redisPushFn *old = NULL;
979:    redisReply *reply;
988:    reply = redisCommand(c, "GET key:0");
993:    reply = redisCommand(c, "SET key:0 val:0");
997:    assert((reply = redisCommand(c, "GET key:0")) != NULL);
1000:    old = redisSetPushCallback(c, push_handler);
1002:    reply = redisCommand(c, "SET key:0 val:0");
1007:    reply = redisCommand(c, "PING");
1012:    reply = redisCommand(c, "FLUSHDB");
1015:    reply = redisCommand(c, "PING");
1022:    redisSetPushCallback(c, NULL);
1023:    assert((reply = redisCommand(c, "GET key:0")) != NULL);
1025:    assert((reply = redisCommand(c, "SET key:0 invalid")) != NULL);
1030:        reply = redisCommand(c, "PING");
1036:    assert(redisGetReply(c, (void**)&reply) == REDIS_OK);
1042:    redisSetPushCallback(c, old);
1050:redisOptions get_redis_tcp_options(struct config config) {
1051:    redisOptions options = {0};
1057:    redisAsyncContext *ac;
1058:    redisContext *c;
1059:    redisOptions options;
1061:    test("We set a default RESP3 handler for redisContext: ");
1062:    options = get_redis_tcp_options(config);
1063:    assert((c = redisConnectWithOptions(&options)) != NULL);
1065:    redisFree(c);
1067:    test("We don't set a default RESP3 push handler for redisAsyncContext: ");
1068:    options = get_redis_tcp_options(config);
1069:    assert((ac = redisAsyncConnectWithOptions(&options)) != NULL);
1071:    redisAsyncFree(ac);
1074:    options = get_redis_tcp_options(config);
1076:    assert((c = redisConnectWithOptions(&options)) != NULL);
1078:    redisFree(c);
1080:    test("We can use redisOptions to set a custom PUSH handler for redisContext: ");
1081:    options = get_redis_tcp_options(config);
1083:    assert((c = redisConnectWithOptions(&options)) != NULL);
1085:    redisFree(c);
1087:    test("We can use redisOptions to set a custom PUSH handler for redisAsyncContext: ");
1088:    options = get_redis_tcp_options(config);
1090:    assert((ac = redisAsyncConnectWithOptions(&options)) != NULL);
1092:    redisAsyncFree(ac);
1102:    redisOptions options;
1103:    redisContext *c;
1105:    test("We can use redisOptions to set privdata: ");
1106:    options = get_redis_tcp_options(config);
1108:    assert((c = redisConnectWithOptions(&options)) != NULL);
1112:    redisFree(c);
1117:    redisContext *c;
1118:    redisReply *reply;
1124:    reply = redisCommand(c,"PING");
1130:    reply = redisCommand(c,"SET foo bar");
1136:    reply = redisCommand(c,"SET %s %s","foo","hello world");
1138:    reply = redisCommand(c,"GET foo");
1144:    reply = redisCommand(c,"SET %b %b","foo",(size_t)3,"hello\x00world",(size_t)11);
1146:    reply = redisCommand(c,"GET foo");
1155:    reply = redisCommand(c,"GET nokey");
1161:    reply = redisCommand(c,"INCR mycounter");
1166:    freeReplyObject(redisCommand(c,"LPUSH mylist foo"));
1167:    freeReplyObject(redisCommand(c,"LPUSH mylist bar"));
1168:    reply = redisCommand(c,"LRANGE mylist 0 -1");
1178:    freeReplyObject(redisCommand(c,"MULTI"));
1179:    freeReplyObject(redisCommand(c,"LRANGE mylist 0 -1"));
1180:    freeReplyObject(redisCommand(c,"PING"));
1181:    reply = (redisCommand(c,"EXEC"));
1195:    reply = redisCommandArgv(c,3,argv,argvlen);
1199:    /* Make sure passing NULL to redisGetReply is safe */
1200:    test("Can pass NULL to redisGetReply: ");
1201:    assert(redisAppendCommand(c, "PING") == REDIS_OK);
1202:    test_cond(redisGetReply(c, NULL) == REDIS_OK);
1204:    get_redis_version(c, &major, NULL);
1214:static int detect_debug_sleep(redisContext *c) {
1216:    redisReply *reply = redisCommand(c, "DEBUG SLEEP 0\r\n");
1231:    redisContext *c;
1232:    redisReply *reply;
1239:    reply = redisCommand(c,"SET foo fast");
1243:    redisSetTimeout(c, tv);
1244:    reply = redisCommand(c, "GET foo");
1252:        redisAppendFormattedCommand(c, sleep_cmd, strlen(sleep_cmd));
1262:        redisSetTimeout(c, tv);
1263:        reply = redisCommand(c, "GET foo");
1281:    reply = redisCommand(c, "PING");
1289:    reply = redisCommand(c, "PING");
1297:    redisContext *c;
1298:    redisReply *reply;
1304:    get_redis_version(c, &major, &minor);
1307:    reply = redisCommand(c,"QUIT");
1312:            redisGetReply(c,&_reply) == REDIS_ERR);
1327:    redisFree(c);
1332:    assert(redisSetTimeout(c,tv) == REDIS_OK);
1333:    int respcode = redisGetReply(c,&_reply);
1339:    redisFree(c);
1343:    redisContext *c;
1351:        c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.connect_timeout);
1353:        c = redisConnectUnixWithTimeout(config.unix_sock.path, config.connect_timeout);
1359:    redisFree(c);
1367:        c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.connect_timeout);
1369:        c = redisConnectUnixWithTimeout(config.unix_sock.path, config.connect_timeout);
1375:    redisFree(c);
1391:    redisContext *c = do_connect(config);
1392:    redisReply **replies;
1398:        freeReplyObject(redisCommand(c,"LPUSH mylist foo"));
1401:    replies = hi_malloc_safe(sizeof(redisReply*)*num);
1404:        replies[i] = redisCommand(c,"PING");
1412:    replies = hi_malloc_safe(sizeof(redisReply*)*num);
1415:        replies[i] = redisCommand(c,"LRANGE mylist 0 499");
1424:    replies = hi_malloc_safe(sizeof(redisReply*)*num);
1427:        replies[i] = redisCommand(c, "INCRBY incrkey %d", 1000000);
1436:    replies = hi_malloc_safe(sizeof(redisReply*)*num);
1438:        redisAppendCommand(c,"PING");
1441:        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);
1449:    replies = hi_malloc_safe(sizeof(redisReply*)*num);
1451:        redisAppendCommand(c,"LRANGE mylist 0 499");
1454:        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);
1463:    replies = hi_malloc_safe(sizeof(redisReply*)*num);
1465:        redisAppendCommand(c,"INCRBY incrkey %d", 1000000);
1468:        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);
1480:// static void __test_callback(redisContext *c, void *privdata) {
1487:// static void __test_reply_callback(redisContext *c, redisReply *reply, void *privdata) {
1495:// static redisContext *__connect_nonblock() {
1498://     return redisConnectNonBlock("127.0.0.1", port, NULL);
1502://     redisContext *c;
1507://     redisSetCommandCallback(c,__test_callback,(void*)1);
1508://     redisCommand(c,"PING");
1510://     redisFree(c);
1512://     test("Calls disconnect callback on redisDisconnect: ");
1514://     redisSetDisconnectCallback(c,__test_callback,(void*)2);
1515://     redisDisconnect(c);
1517://     redisFree(c);
1519://     test("Calls disconnect callback and free callback on redisFree: ");
1521://     redisSetDisconnectCallback(c,__test_callback,(void*)2);
1522://     redisSetFreeCallback(c,__test_callback,(void*)4);
1523://     redisFree(c);
1526://     test("redisBufferWrite against empty write buffer: ");
1528://     test_cond(redisBufferWrite(c,&wdone) == REDIS_OK && wdone == 1);
1529://     redisFree(c);
1531://     test("redisBufferWrite against not yet connected fd: ");
1533://     redisCommand(c,"PING");
1534://     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&
1536://     redisFree(c);
1538://     test("redisBufferWrite against closed fd: ");
1540://     redisCommand(c,"PING");
1541://     redisDisconnect(c);
1542://     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&
1544://     redisFree(c);
1548://     redisCommandWithCallback(c,__test_reply_callback,(void*)1,"PING");
1549://     redisCommandWithCallback(c,__test_reply_callback,(void*)2,"PING");
1550://     redisCommandWithCallback(c,__test_reply_callback,(void*)3,"PING");
1556://         redisBufferWrite(c,&wdone);
1563://         assert(redisBufferRead(c) == REDIS_OK);
1564://         redisProcessCallbacks(c);
1567://     redisFree(c);
1569://     test("redisDisconnect executes pending callbacks with NULL reply: ");
1571://     redisSetDisconnectCallback(c,__test_callback,(void*)1);
1572://     redisCommandWithCallback(c,__test_reply_callback,(void*)2,"PING");
1573://     redisDisconnect(c);
1575://     redisFree(c);
1585:    redisOptions *options;
1592:void async_disconnect(redisAsyncContext *ac) {
1593:    redisAsyncDisconnect(ac);
1605:void unexpected_cb(redisAsyncContext *ac, void *r, void *privdata) {
1612:void publish_msg(redisOptions *options, const char* channel, const char* msg) {
1613:    redisContext *c = redisConnectWithOptions(options);
1615:    redisReply *reply = redisCommand(c,"PUBLISH %s %s",channel,msg);
1622:void integer_cb(redisAsyncContext *ac, void *r, void *privdata) {
1623:    redisReply *reply = r;
1633:void subscribe_cb(redisAsyncContext *ac, void *r, void *privdata) {
1634:    redisReply *reply = r;
1652:        redisAsyncCommand(ac,unexpected_cb,
1657:        redisAsyncCommand(ac,integer_cb,state,"LPUSH mylist foo");
1669:void array_cb(redisAsyncContext *ac, void *r, void *privdata) {
1670:    redisReply *reply = r;
1678:void null_cb(redisAsyncContext *ac, void *r, void *privdata) {
1697:    redisOptions options = get_redis_tcp_options(config);
1698:    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);
1700:    redisLibeventAttach(ac,base);
1704:    redisAsyncCommand(ac,subscribe_cb,&state,"subscribe mychannel");
1707:    redisAsyncCommand(ac,array_cb,&state,"PING");
1719:void unexpected_push_cb(redisAsyncContext *ac, void *r) {
1737:    redisOptions options = get_redis_tcp_options(config);
1738:    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);
1740:    redisLibeventAttach(ac,base);
1743:    redisAsyncSetPushCallback(ac, unexpected_push_cb);
1746:    redisAsyncCommand(ac,NULL,NULL,"HELLO 3");
1750:    redisAsyncCommand(ac,subscribe_cb,&state,"subscribe mychannel");
1753:    redisAsyncCommand(ac,integer_cb,&state,"LPUSH mylist foo");
1754:    redisAsyncCommand(ac,integer_cb,&state,"LPUSH mylist foo");
1755:    redisAsyncCommand(ac,integer_cb,&state,"LPUSH mylist foo");
1757:    redisAsyncCommand(ac,array_cb,&state,"LRANGE mylist 0 2");
1772:void subscribe_with_timeout_cb(redisAsyncContext *ac, void *r, void *privdata) {
1773:    redisReply *reply = r;
1798:        redisAsyncCommand(ac,null_cb,state,"DEBUG SLEEP 3");
1799:        redisAsyncCommand(ac,null_cb,state,"LPUSH mylist foo");
1818:    redisOptions options = get_redis_tcp_options(config);
1819:    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);
1821:    redisLibeventAttach(ac,base);
1825:    redisAsyncSetTimeout(ac,command_timeout);
1828:    redisAsyncSetPushCallback(ac,unexpected_push_cb);
1831:    redisAsyncCommand(ac,NULL,NULL,"HELLO 3");
1835:    redisAsyncCommand(ac,subscribe_with_timeout_cb,&state,"subscribe mychannel");
1847:void subscribe_channel_a_cb(redisAsyncContext *ac, void *r, void *privdata) {
1848:    redisReply *reply = r;
1864:        redisAsyncCommand(ac,unexpected_cb,
1868:        redisAsyncCommand(ac,unexpected_cb,
1873:        redisAsyncCommand(ac,integer_cb,state,"LPUSH mylist foo");
1884:void subscribe_channel_b_cb(redisAsyncContext *ac, void *r, void *privdata) {
1885:    redisReply *reply = r;
1923:    redisOptions options = get_redis_tcp_options(config);
1924:    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);
1926:    redisLibeventAttach(ac,base);
1929:    redisAsyncSetPushCallback(ac,unexpected_push_cb);
1933:    redisAsyncCommand(ac,subscribe_channel_a_cb,&state,"subscribe A");
1934:    redisAsyncCommand(ac,subscribe_channel_b_cb,&state,"subscribe B");
1946:void monitor_cb(redisAsyncContext *ac, void *r, void *privdata) {
1947:    redisReply *reply = r;
1961:        redisContext *c = redisConnectWithOptions(state->options);
1963:        redisReply *reply = redisCommand(c,"SET first 1");
1966:        redisFree(c);
1970:        redisContext *c = redisConnectWithOptions(state->options);
1972:        redisReply *reply = redisCommand(c,"SET second 2");
1975:        redisFree(c);
1980:        redisAsyncCommand(ac,NULL,NULL,"QUIT");
2000:    redisOptions options = get_redis_tcp_options(config);
2001:    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);
2003:    redisLibeventAttach(ac,base);
2006:    redisAsyncSetPushCallback(ac,unexpected_push_cb);
2010:    redisAsyncCommand(ac,monitor_cb,&state,"monitor");
2037:    redisAsyncContext *ac;
2058:static void commandCallback(struct redisAsyncContext *ac, void* _reply, void* _privdata);
2060:static void connectCallback(redisAsyncContext *c, int status) {
2072:        redisAsyncDisconnect(c);
2076:        redisAsyncCommand(c, commandCallback, NULL, "PING");
2079:static void disconnectCallback(const redisAsyncContext *c, int status) {
2089:static void commandCallback(struct redisAsyncContext *ac, void* _reply, void* _privdata)
2091:    redisReply *reply = (redisReply*)_reply;
2102:        redisAsyncFree(ac);
2110:            int status = redisAsyncCommand(ac, commandCallback, NULL, "PING");
2113:            redisAsyncFree(ac);
2118:static redisAsyncContext *do_aconnect(struct config config, astest_no testno)
2120:    redisOptions options = {0};
2140:        redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);
2142:            redisFD fd = disconnect(dummy_ctx, 1);
2147:    redisAsyncContext *c = redisAsyncConnectWithOptions(&options);
2152:    redisPollAttach(c);
2153:    redisAsyncSetConnectCallbackNC(c, connectCallback);
2154:    redisAsyncSetDisconnectCallback(c, disconnectCallback);
2170:    redisAsyncContext *c;
2177:        redisPollTick(c, 0.1);
2185:    redisAsyncFree(c);
2199:            redisPollTick(c, 0.1);
2203:         *redisAsyncFree(c);
2214:        redisPollTick(c, 0.1);
2215:    status = redisAsyncCommand(c, commandCallback, NULL, "PING");
2218:        redisPollTick(c, 0.1);
2222:     * see https://github.com/redis/hiredis/issues/945
2229:            redisPollTick(c, 0.1);
2232:        status = redisAsyncCommand(c, commandCallback, NULL, "PING");
2235:            redisPollTick(c, 0.1);
2241:     * see https://github.com/redis/hiredis/issues/931
2246:        redisPollTick(c, 0.1);
2252:     * see https://github.com/redis/hiredis/issues/931
2258:        redisPollTick(c, 0.1);
2273:            .path = "/tmp/redis.sock"
2367:        redisInitOpenSSL();
2368:        _ssl_ctx = redisCreateSSLContext(cfg.ssl.ca_cert, NULL, cfg.ssl.cert, cfg.ssl.key, NULL, NULL);
2381:        redisFreeSSLContext(_ssl_ctx);
2392:    redisContext *c = do_connect(cfg);
2393:    get_redis_version(c, &major, NULL);

deps/hiredis/net.c
1:/* Extracted from anet.c to work properly with Hiredis error reporting.
50:/* Defined in hiredis.c */
51:void __redisSetError(redisContext *c, int type, const char *str);
53:int redisContextUpdateCommandTimeout(redisContext *c, const struct timeval *timeout);
55:void redisNetClose(redisContext *c) {
62:ssize_t redisNetRead(redisContext *c, char *buf, size_t bufcap) {
70:            __redisSetError(c, REDIS_ERR_TIMEOUT, "recv timeout");
73:            __redisSetError(c, REDIS_ERR_IO, strerror(errno));
77:        __redisSetError(c, REDIS_ERR_EOF, "Server closed the connection");
84:ssize_t redisNetWrite(redisContext *c) {
93:            __redisSetError(c, REDIS_ERR_IO, strerror(errno));
101:static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
109:    __redisSetError(c,type,buf);
112:static int redisSetReuseAddr(redisContext *c) {
115:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
116:        redisNetClose(c);
122:static int redisCreateSocket(redisContext *c, int type) {
123:    redisFD s;
125:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
130:        if (redisSetReuseAddr(c) == REDIS_ERR) {
137:static int redisSetBlocking(redisContext *c, int blocking) {
145:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_GETFL)");
146:        redisNetClose(c);
156:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_SETFL)");
157:        redisNetClose(c);
163:        __redisSetErrorFromErrno(c, REDIS_ERR_IO, "ioctl(FIONBIO)");
164:        redisNetClose(c);
171:int redisKeepAlive(redisContext *c, int interval) {
173:    redisFD fd = c->fd;
177:        __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
185:        __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
191:        __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
198:        __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
204:        __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
212:    res = win32_redisKeepAlive(fd, interval * 1000);
214:        __redisSetError(c, REDIS_ERR_OTHER, strerror(res));
221:int redisSetTcpNoDelay(redisContext *c) {
224:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(TCP_NODELAY)");
225:        redisNetClose(c);
231:int redisContextSetTcpUserTimeout(redisContext *c, unsigned int timeout) {
241:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(TCP_USER_TIMEOUT)");
242:        redisNetClose(c);
250:static int redisContextTimeoutMsec(redisContext *c, long *result)
258:            __redisSetError(c, REDIS_ERR_IO, "Invalid timeout specified");
274:static int redisContextWaitReady(redisContext *c, long msec) {
284:            __redisSetErrorFromErrno(c, REDIS_ERR_IO, "poll(2)");
285:            redisNetClose(c);
289:            __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
290:            redisNetClose(c);
294:        if (redisCheckConnectDone(c, &res) != REDIS_OK || res == 0) {
295:            redisCheckSocketError(c);
302:    __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
303:    redisNetClose(c);
307:int redisCheckConnectDone(redisContext *c, int *completed) {
343:int redisCheckSocketError(redisContext *c) {
348:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"getsockopt(SO_ERROR)");
358:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
365:int redisContextSetTimeout(redisContext *c, const struct timeval tv) {
369:    if (redisContextUpdateCommandTimeout(c, &tv) != REDIS_OK) {
370:        __redisSetError(c, REDIS_ERR_OOM, "Out of memory");
374:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_RCVTIMEO)");
378:        __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_SNDTIMEO)");
384:int redisContextUpdateConnectTimeout(redisContext *c, const struct timeval *timeout) {
400:int redisContextUpdateCommandTimeout(redisContext *c, const struct timeval *timeout) {
416:static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
419:    redisFD s;
448:        if (redisContextUpdateConnectTimeout(c, timeout) == REDIS_ERR)
455:    if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {
489:        __redisSetError(c, REDIS_ERR_OTHER, gai_strerror(rv));
498:        if (redisSetBlocking(c,0) != REDIS_OK)
506:                __redisSetError(c,REDIS_ERR_OTHER,buf);
529:                __redisSetError(c,REDIS_ERR_OTHER,buf);
545:                redisNetClose(c);
559:                    redisNetClose(c);
564:                if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)
566:                if (redisSetTcpNoDelay(c) != REDIS_OK)
570:        if (blocking && redisSetBlocking(c,1) != REDIS_OK)
580:        __redisSetError(c,REDIS_ERR_OTHER,buf);
585:    __redisSetError(c, REDIS_ERR_OOM, "Out of memory");
596:int redisContextConnectTcp(redisContext *c, const char *addr, int port,
598:    return _redisContextConnectTcp(c, addr, port, timeout, NULL);
601:int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
604:    return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
607:int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
613:    if (redisCreateSocket(c,AF_UNIX) < 0)
615:    if (redisSetBlocking(c,0) != REDIS_OK)
628:        if (redisContextUpdateConnectTimeout(c, timeout) == REDIS_ERR)
635:    if (redisContextTimeoutMsec(c,&timeout_msec) != REDIS_OK)
652:            if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)
658:    if (blocking && redisSetBlocking(c,1) != REDIS_OK)
670:    __redisSetError(c, REDIS_ERR_OOM, "Out of memory");

deps/hiredis/examples/example-glib.c
3:#include <hiredis.h>
10:connect_cb (const redisAsyncContext *ac G_GNUC_UNUSED,
22:disconnect_cb (const redisAsyncContext *ac G_GNUC_UNUSED,
34:command_cb(redisAsyncContext *ac,
38:    redisReply *reply = r;
44:    redisAsyncDisconnect(ac);
51:    redisAsyncContext *ac;
55:    ac = redisAsyncConnect("127.0.0.1", 6379);
61:    source = redis_source_new(ac);
65:    redisAsyncSetConnectCallback(ac, connect_cb);
66:    redisAsyncSetDisconnectCallback(ac, disconnect_cb);
67:    redisAsyncCommand(ac, command_cb, NULL, "SET key 1234");
68:    redisAsyncCommand(ac, command_cb, NULL, "GET key");

deps/hiredis/examples/example-poll.c
13:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
14:    redisReply *reply = r;
19:    redisAsyncDisconnect(c);
22:void connectCallback(const redisAsyncContext *c, int status) {
32:void disconnectCallback(const redisAsyncContext *c, int status) {
45:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
52:    redisPollAttach(c);
53:    redisAsyncSetConnectCallback(c,connectCallback);
54:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
55:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
56:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
59:        redisPollTick(c, 0.1);

deps/hiredis/examples/example-libev.c
6:#include <hiredis.h>
10:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
11:    redisReply *reply = r;
16:    redisAsyncDisconnect(c);
19:void connectCallback(const redisAsyncContext *c, int status) {
27:void disconnectCallback(const redisAsyncContext *c, int status) {
40:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
47:    redisLibevAttach(EV_DEFAULT_ c);
48:    redisAsyncSetConnectCallback(c,connectCallback);
49:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
50:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
51:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example.c
4:#include <hiredis.h>
10:static void example_argv_command(redisContext *c, size_t n) {
13:    redisReply *reply;
33:    /* Execute the command using redisCommandArgv.  We're sending the arguments with
36:    reply = redisCommandArgv(c, n + 2, (const char **)argv, (const size_t*)argvlen);
39:        fprintf(stderr, "Error:  Couldn't execute redisCommandArgv\n");
60:    redisContext *c;
61:    redisReply *reply;
76:        c = redisConnectUnixWithTimeout(hostname, timeout);
78:        c = redisConnectWithTimeout(hostname, port, timeout);
83:            redisFree(c);
85:            printf("Connection error: can't allocate redis context\n");
91:    reply = redisCommand(c,"PING");
96:    reply = redisCommand(c,"SET %s %s", "foo", "hello world");
101:    reply = redisCommand(c,"SET %b %b", "bar", (size_t) 3, "hello", (size_t) 5);
106:    reply = redisCommand(c,"GET foo");
110:    reply = redisCommand(c,"INCR counter");
114:    reply = redisCommand(c,"INCR counter");
119:    reply = redisCommand(c,"DEL mylist");
125:        reply = redisCommand(c,"LPUSH mylist element-%s", buf);
130:    reply = redisCommand(c,"LRANGE mylist 0 -1");
138:    /* See function for an example of redisCommandArgv */
142:    redisFree(c);

deps/hiredis/examples/example-libevent-ssl.c
6:#include <hiredis.h>
7:#include <hiredis_ssl.h>
11:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
12:    redisReply *reply = r;
17:    redisAsyncDisconnect(c);
20:void connectCallback(const redisAsyncContext *c, int status) {
28:void disconnectCallback(const redisAsyncContext *c, int status) {
58:    redisSSLContext *ssl;
59:    redisSSLContextError ssl_error = REDIS_SSL_CTX_NONE;
61:    redisInitOpenSSL();
63:    ssl = redisCreateSSLContext(caCert, NULL,
66:        printf("Error: %s\n", redisSSLContextGetError(ssl_error));
70:    redisAsyncContext *c = redisAsyncConnect(hostname, port);
76:    if (redisInitiateSSLWithContext(&c->c, ssl) != REDIS_OK) {
81:    redisLibeventAttach(c,base);
82:    redisAsyncSetConnectCallback(c,connectCallback);
83:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
84:    redisAsyncCommand(c, NULL, NULL, "SET key %b", value, nvalue);
85:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
88:    redisFreeSSLContext(ssl);

deps/hiredis/examples/example-push.c
33:#include <hiredis.h>
43:static void assertReplyAndFree(redisContext *context, redisReply *reply, int type) {
58:static void enableClientTracking(redisContext *c) {
59:    redisReply *reply = redisCommand(c, "HELLO 3");
66:        fprintf(stderr, "connected to redis-server >= 6.0.0?\nRedis error: %s\n",
74:    reply = redisCommand(c, "CLIENT TRACKING ON");
79:    redisReply *reply = r;
100: * have hiredis call our data destructor when freeing the context */
108:    redisContext *c;
109:    redisReply *reply;
114:    redisOptions o = {0};
118:     * time our PUSH handler is called, hiredis will pass the privdata for context.
130:    c = redisConnectWithOptions(&o);
140:        reply = redisCommand(c, "SET key:%d initial:%d", j, j);
143:        reply = redisCommand(c, "GET key:%d", j);
150:        reply = redisCommand(c, "SET key:%d update:%d", j, j);
158:    redisFree(c);

deps/hiredis/examples/example-ae.c
6:#include <hiredis.h>
13:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
14:    redisReply *reply = r;
19:    redisAsyncDisconnect(c);
22:void connectCallback(const redisAsyncContext *c, int status) {
32:void disconnectCallback(const redisAsyncContext *c, int status) {
46:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
54:    redisAeAttach(loop, c);
55:    redisAsyncSetConnectCallback(c,connectCallback);
56:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
57:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
58:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example-libsdevent.c
6:#include <hiredis.h>
10:void debugCallback(redisAsyncContext *c, void *r, void *privdata) {
12:    redisReply *reply = r;
19:    redisAsyncDisconnect(c);
22:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
23:    redisReply *reply = r;
31:    redisAsyncCommand(c, debugCallback, NULL, "DEBUG SLEEP %f", 1.5);
34:void connectCallback(const redisAsyncContext *c, int status) {
42:void disconnectCallback(const redisAsyncContext *c, int status) {
56:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
59:        redisAsyncFree(c);
63:    redisLibsdeventAttach(c,event);
64:    redisAsyncSetConnectCallback(c,connectCallback);
65:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
66:    redisAsyncSetTimeout(c, (struct timeval){ .tv_sec = 1, .tv_usec = 0});
75:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
76:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example-macosx.c
8:#include <hiredis.h>
12:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
13:    redisReply *reply = r;
18:    redisAsyncDisconnect(c);
21:void connectCallback(const redisAsyncContext *c, int status) {
29:void disconnectCallback(const redisAsyncContext *c, int status) {
47:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
54:    redisMacOSAttach(c, loop);
56:    redisAsyncSetConnectCallback(c,connectCallback);
57:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
59:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
60:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example-libevent.c
6:#include <hiredis.h>
10:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
11:    redisReply *reply = r;
21:    redisAsyncDisconnect(c);
24:void connectCallback(const redisAsyncContext *c, int status) {
32:void disconnectCallback(const redisAsyncContext *c, int status) {
46:    redisOptions options = {0};
53:    redisAsyncContext *c = redisAsyncConnectWithOptions(&options);
60:    redisLibeventAttach(c,base);
61:    redisAsyncSetConnectCallback(c,connectCallback);
62:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
63:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
64:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/CMakeLists.txt
9:    TARGET_LINK_LIBRARIES(example-glib hiredis ${GLIB2_LIBRARIES})
19:    TARGET_LINK_LIBRARIES(example-libev hiredis ev)
25:    TARGET_LINK_LIBRARIES(example-libevent hiredis event)
31:    TARGET_LINK_LIBRARIES(example-libhv hiredis hv)
37:    TARGET_LINK_LIBRARIES(example-libuv hiredis uv)
43:    TARGET_LINK_LIBRARIES(example-libsdevent hiredis systemd)
49:    TARGET_LINK_LIBRARIES(example-macosx hiredis ${CF})
54:    TARGET_LINK_LIBRARIES(example-ssl hiredis hiredis_ssl)
58:TARGET_LINK_LIBRARIES(example hiredis)
61:TARGET_LINK_LIBRARIES(example-push hiredis)

deps/hiredis/examples/example-libuv.c
6:#include <hiredis.h>
10:void debugCallback(redisAsyncContext *c, void *r, void *privdata) {
12:    redisReply *reply = r;
19:    redisAsyncDisconnect(c);
22:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
23:    redisReply *reply = r;
31:    redisAsyncCommand(c, debugCallback, NULL, "DEBUG SLEEP %f", 1.5);
34:void connectCallback(const redisAsyncContext *c, int status) {
42:void disconnectCallback(const redisAsyncContext *c, int status) {
57:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
64:    redisLibuvAttach(c,loop);
65:    redisAsyncSetConnectCallback(c,connectCallback);
66:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
67:    redisAsyncSetTimeout(c, (struct timeval){ .tv_sec = 1, .tv_usec = 0});
76:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
77:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example-qt.h
25:        redisAsyncContext * m_ctx;
29:    void getCallback(redisAsyncContext *, void *, void *);

deps/hiredis/examples/example-qt.cpp
9:void getCallback(redisAsyncContext *, void * r, void * privdata) {
11:    redisReply * reply = static_cast<redisReply *>(r);
22:    m_ctx = redisAsyncConnect("localhost", 6379);
26:        redisAsyncFree(m_ctx);
32:    redisAsyncCommand(m_ctx, NULL, NULL, "SET key %s", m_value);
33:    redisAsyncCommand(m_ctx, getCallback, this, "GET key");

deps/hiredis/examples/example-redismoduleapi.c
6:#include <hiredis.h>
8:#include <adapters/redismoduleapi.h>
10:void debugCallback(redisAsyncContext *c, void *r, void *privdata) {
12:    redisReply *reply = r;
19:    redisAsyncDisconnect(c);
22:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
23:    redisReply *reply = r;
33:    redisAsyncCommand(c, debugCallback, NULL, "DEBUG SLEEP %f", 1.5);
36:void connectCallback(const redisAsyncContext *c, int status) {
44:void disconnectCallback(const redisAsyncContext *c, int status) {
55: * 1- Compile this file as a shared library. Directory of "redismodule.h" must
57: *       gcc -fPIC -shared -I../../redis/src/ -I.. example-redismoduleapi.c -o example-redismoduleapi.so
60: *       redis-server --loadmodule ./example-redismoduleapi.so value
64:    int ret = RedisModule_Init(ctx, "example-redismoduleapi", 1, REDISMODULE_APIVER_1);
70:    if (redisModuleCompatibilityCheck() != REDIS_OK) {
75:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
86:    redisModuleAttach(c, module_ctx);
87:    redisAsyncSetConnectCallback(c,connectCallback);
88:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
89:    redisAsyncSetTimeout(c, (struct timeval){ .tv_sec = 1, .tv_usec = 0});
98:    redisAsyncCommand(c, NULL, NULL, "SET key %b", val, len);
99:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example-libhv.c
6:#include <hiredis.h>
10:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
11:    redisReply *reply = r;
16:    redisAsyncDisconnect(c);
19:void debugCallback(redisAsyncContext *c, void *r, void *privdata) {
21:    redisReply *reply = r;
28:    redisAsyncDisconnect(c);
31:void connectCallback(const redisAsyncContext *c, int status) {
39:void disconnectCallback(const redisAsyncContext *c, int status) {
52:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
60:    redisLibhvAttach(c, loop);
61:    redisAsyncSetTimeout(c, (struct timeval){.tv_sec = 0, .tv_usec = 500000});
62:    redisAsyncSetConnectCallback(c,connectCallback);
63:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
64:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
65:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
66:    redisAsyncCommand(c, debugCallback, NULL, "DEBUG SLEEP %d", 1);

deps/hiredis/examples/example-ivykis.c
6:#include <hiredis.h>
10:void getCallback(redisAsyncContext *c, void *r, void *privdata) {
11:    redisReply *reply = r;
16:    redisAsyncDisconnect(c);
19:void connectCallback(const redisAsyncContext *c, int status) {
27:void disconnectCallback(const redisAsyncContext *c, int status) {
42:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
49:    redisIvykisAttach(c);
50:    redisAsyncSetConnectCallback(c,connectCallback);
51:    redisAsyncSetDisconnectCallback(c,disconnectCallback);
52:    redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
53:    redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");

deps/hiredis/examples/example-ssl.c
5:#include <hiredis.h>
6:#include <hiredis_ssl.h>
14:    redisSSLContext *ssl;
15:    redisSSLContextError ssl_error = REDIS_SSL_CTX_NONE;
16:    redisContext *c;
17:    redisReply *reply;
28:    redisInitOpenSSL();
29:    ssl = redisCreateSSLContext(ca, NULL, cert, key, NULL, &ssl_error);
31:        printf("SSL Context error: %s\n", redisSSLContextGetError(ssl_error));
36:    redisOptions options = {0};
39:    c = redisConnectWithOptions(&options);
44:            redisFree(c);
46:            printf("Connection error: can't allocate redis context\n");
51:    if (redisInitiateSSLWithContext(c, ssl) != REDIS_OK) {
54:        redisFree(c);
59:    reply = redisCommand(c,"PING");
64:    reply = redisCommand(c,"SET %s %s", "foo", "hello world");
69:    reply = redisCommand(c,"SET %b %b", "bar", (size_t) 3, "hello", (size_t) 5);
74:    reply = redisCommand(c,"GET foo");
78:    reply = redisCommand(c,"INCR counter");
82:    reply = redisCommand(c,"INCR counter");
87:    reply = redisCommand(c,"DEL mylist");
93:        reply = redisCommand(c,"LPUSH mylist element-%s", buf);
98:    reply = redisCommand(c,"LRANGE mylist 0 -1");
107:    redisFree(c);
109:    redisFreeSSLContext(ssl);

deps/hiredis/hiredis.pc.in
6:pkgincludedir=${includedir}/hiredis
8:Name: hiredis
11:Libs: -L${libdir} -lhiredis

deps/hiredis/async_private.h
56:static inline void refreshTimeout(redisAsyncContext *ctx) {
72:void __redisAsyncDisconnect(redisAsyncContext *ac);
73:void redisProcessCallbacks(redisAsyncContext *ac);

deps/hiredis/async.h
34:#include "hiredis.h"
40:struct redisAsyncContext; /* need forward declaration of redisAsyncContext */
44:typedef void (redisCallbackFn)(struct redisAsyncContext*, void*, void*);
45:typedef struct redisCallback {
46:    struct redisCallback *next; /* simple singly linked list */
47:    redisCallbackFn *fn;
51:} redisCallback;
54:typedef struct redisCallbackList {
55:    redisCallback *head, *tail;
56:} redisCallbackList;
59:typedef void (redisDisconnectCallback)(const struct redisAsyncContext*, int status);
60:typedef void (redisConnectCallback)(const struct redisAsyncContext*, int status);
61:typedef void (redisConnectCallbackNC)(struct redisAsyncContext *, int status);
62:typedef void(redisTimerCallback)(void *timer, void *privdata);
65:typedef struct redisAsyncContext {
67:    redisContext c;
73:    /* Not used by hiredis */
93:    redisDisconnectCallback *onDisconnect;
96:    redisConnectCallback *onConnect;
97:    redisConnectCallbackNC *onConnectNC;
100:    redisCallbackList replies;
108:        redisCallbackList replies;
115:    redisAsyncPushFn *push_cb;
116:} redisAsyncContext;
118:/* Functions that proxy to hiredis */
119:redisAsyncContext *redisAsyncConnectWithOptions(const redisOptions *options);
120:redisAsyncContext *redisAsyncConnect(const char *ip, int port);
121:redisAsyncContext *redisAsyncConnectBind(const char *ip, int port, const char *source_addr);
122:redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,
124:redisAsyncContext *redisAsyncConnectUnix(const char *path);
125:int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn);
126:int redisAsyncSetConnectCallbackNC(redisAsyncContext *ac, redisConnectCallbackNC *fn);
127:int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);
129:redisAsyncPushFn *redisAsyncSetPushCallback(redisAsyncContext *ac, redisAsyncPushFn *fn);
130:int redisAsyncSetTimeout(redisAsyncContext *ac, struct timeval tv);
131:void redisAsyncDisconnect(redisAsyncContext *ac);
132:void redisAsyncFree(redisAsyncContext *ac);
135:void redisAsyncHandleRead(redisAsyncContext *ac);
136:void redisAsyncHandleWrite(redisAsyncContext *ac);
137:void redisAsyncHandleTimeout(redisAsyncContext *ac);
138:void redisAsyncRead(redisAsyncContext *ac);
139:void redisAsyncWrite(redisAsyncContext *ac);
143:int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap);
144:int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...);
145:int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen);
146:int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len);

deps/hiredis/appveyor.yml
1:# Appveyor configuration file for CI build of hiredis on Windows (under Cygwin)

deps/hiredis/read.c
53:static void __redisReaderSetError(redisReader *r, int type, const char *str) {
101:static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {
107:    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,sbuf);
110:static void __redisReaderSetErrorOOM(redisReader *r) {
111:    __redisReaderSetError(r,REDIS_ERR_OOM,"Out of memory");
114:static char *readBytes(redisReader *r, unsigned int bytes) {
225:static char *readLine(redisReader *r, int *_len) {
240:static void moveToNextTask(redisReader *r) {
241:    redisReadTask *cur, *prv;
268:static int processLineItem(redisReader *r) {
269:    redisReadTask *cur = r->task[r->ridx];
279:                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
294:                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
316:                    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
329:                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
342:                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
359:                    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
372:                    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
384:            __redisReaderSetErrorOOM(r);
397:static int processBulkItem(redisReader *r) {
398:    redisReadTask *cur = r->task[r->ridx];
412:            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
418:            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
437:                    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
453:                __redisReaderSetErrorOOM(r);
469:static int redisReaderGrow(redisReader *r) {
470:    redisReadTask **aux;
490:    __redisReaderSetErrorOOM(r);
495:static int processAggregateItem(redisReader *r) {
496:    redisReadTask *cur = r->task[r->ridx];
503:        if (redisReaderGrow(r) == REDIS_ERR)
509:            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
519:            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
531:                __redisReaderSetErrorOOM(r);
545:                __redisReaderSetErrorOOM(r);
573:static int processItem(redisReader *r) {
574:    redisReadTask *cur = r->task[r->ridx];
621:                __redisReaderSetErrorProtocolByte(r,*p);
654:redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {
655:    redisReader *r;
657:    r = hi_calloc(1,sizeof(redisReader));
682:    redisReaderFree(r);
686:void redisReaderFree(redisReader *r) {
706:int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
733:    __redisReaderSetErrorOOM(r);
737:int redisReaderGetReply(redisReader *r, void **reply) {

deps/hiredis/alloc.c
36:hiredisAllocFuncs hiredisAllocFns = {
44:/* Override hiredis' allocators with ones supplied by the user */
45:hiredisAllocFuncs hiredisSetAllocators(hiredisAllocFuncs *override) {
46:    hiredisAllocFuncs orig = hiredisAllocFns;
48:    hiredisAllocFns = *override;
54:void hiredisResetAllocators(void) {
55:    hiredisAllocFns = (hiredisAllocFuncs) {
67:    return hiredisAllocFns.mallocFn(size);
75:    return hiredisAllocFns.callocFn(nmemb, size);
79:    return hiredisAllocFns.reallocFn(ptr, size);
83:    return hiredisAllocFns.strdupFn(str);
87:    hiredisAllocFns.freeFn(ptr);

deps/hiredis/adapters/ivykis.h
4:#include "../hiredis.h"
7:typedef struct redisIvykisEvents {
8:    redisAsyncContext *context;
10:} redisIvykisEvents;
12:static void redisIvykisReadEvent(void *arg) {
13:    redisAsyncContext *context = (redisAsyncContext *)arg;
14:    redisAsyncHandleRead(context);
17:static void redisIvykisWriteEvent(void *arg) {
18:    redisAsyncContext *context = (redisAsyncContext *)arg;
19:    redisAsyncHandleWrite(context);
22:static void redisIvykisAddRead(void *privdata) {
23:    redisIvykisEvents *e = (redisIvykisEvents*)privdata;
24:    iv_fd_set_handler_in(&e->fd, redisIvykisReadEvent);
27:static void redisIvykisDelRead(void *privdata) {
28:    redisIvykisEvents *e = (redisIvykisEvents*)privdata;
32:static void redisIvykisAddWrite(void *privdata) {
33:    redisIvykisEvents *e = (redisIvykisEvents*)privdata;
34:    iv_fd_set_handler_out(&e->fd, redisIvykisWriteEvent);
37:static void redisIvykisDelWrite(void *privdata) {
38:    redisIvykisEvents *e = (redisIvykisEvents*)privdata;
42:static void redisIvykisCleanup(void *privdata) {
43:    redisIvykisEvents *e = (redisIvykisEvents*)privdata;
49:static int redisIvykisAttach(redisAsyncContext *ac) {
50:    redisContext *c = &(ac->c);
51:    redisIvykisEvents *e;
58:    e = (redisIvykisEvents*)hi_malloc(sizeof(*e));
65:    ac->ev.addRead = redisIvykisAddRead;
66:    ac->ev.delRead = redisIvykisDelRead;
67:    ac->ev.addWrite = redisIvykisAddWrite;
68:    ac->ev.delWrite = redisIvykisDelWrite;
69:    ac->ev.cleanup = redisIvykisCleanup;
75:    e->fd.handler_in = redisIvykisReadEvent;
76:    e->fd.handler_out = redisIvykisWriteEvent;

deps/hiredis/adapters/macosx.h
11:#include "../hiredis.h"
15:    redisAsyncContext *context;
20:static int freeRedisRunLoop(RedisRunLoop* redisRunLoop) {
21:    if( redisRunLoop != NULL ) {
22:        if( redisRunLoop->sourceRef != NULL ) {
23:            CFRunLoopSourceInvalidate(redisRunLoop->sourceRef);
24:            CFRelease(redisRunLoop->sourceRef);
26:        if( redisRunLoop->socketRef != NULL ) {
27:            CFSocketInvalidate(redisRunLoop->socketRef);
28:            CFRelease(redisRunLoop->socketRef);
30:        hi_free(redisRunLoop);
35:static void redisMacOSAddRead(void *privdata) {
36:    RedisRunLoop *redisRunLoop = (RedisRunLoop*)privdata;
37:    CFSocketEnableCallBacks(redisRunLoop->socketRef, kCFSocketReadCallBack);
40:static void redisMacOSDelRead(void *privdata) {
41:    RedisRunLoop *redisRunLoop = (RedisRunLoop*)privdata;
42:    CFSocketDisableCallBacks(redisRunLoop->socketRef, kCFSocketReadCallBack);
45:static void redisMacOSAddWrite(void *privdata) {
46:    RedisRunLoop *redisRunLoop = (RedisRunLoop*)privdata;
47:    CFSocketEnableCallBacks(redisRunLoop->socketRef, kCFSocketWriteCallBack);
50:static void redisMacOSDelWrite(void *privdata) {
51:    RedisRunLoop *redisRunLoop = (RedisRunLoop*)privdata;
52:    CFSocketDisableCallBacks(redisRunLoop->socketRef, kCFSocketWriteCallBack);
55:static void redisMacOSCleanup(void *privdata) {
56:    RedisRunLoop *redisRunLoop = (RedisRunLoop*)privdata;
57:    freeRedisRunLoop(redisRunLoop);
60:static void redisMacOSAsyncCallback(CFSocketRef __unused s, CFSocketCallBackType callbackType, CFDataRef __unused address, const void __unused *data, void *info) {
61:    redisAsyncContext* context = (redisAsyncContext*) info;
65:            redisAsyncHandleRead(context);
69:            redisAsyncHandleWrite(context);
77:static int redisMacOSAttach(redisAsyncContext *redisAsyncCtx, CFRunLoopRef runLoop) {
78:    redisContext *redisCtx = &(redisAsyncCtx->c);
81:    if( redisAsyncCtx->ev.data != NULL ) return REDIS_ERR;
83:    RedisRunLoop* redisRunLoop = (RedisRunLoop*) hi_calloc(1, sizeof(RedisRunLoop));
84:    if (redisRunLoop == NULL)
87:    /* Setup redis stuff */
88:    redisRunLoop->context = redisAsyncCtx;
90:    redisAsyncCtx->ev.addRead  = redisMacOSAddRead;
91:    redisAsyncCtx->ev.delRead  = redisMacOSDelRead;
92:    redisAsyncCtx->ev.addWrite = redisMacOSAddWrite;
93:    redisAsyncCtx->ev.delWrite = redisMacOSDelWrite;
94:    redisAsyncCtx->ev.cleanup  = redisMacOSCleanup;
95:    redisAsyncCtx->ev.data     = redisRunLoop;
98:    CFSocketContext socketCtx = { 0, redisAsyncCtx, NULL, NULL, NULL };
100:    redisRunLoop->socketRef = CFSocketCreateWithNative(NULL, redisCtx->fd,
102:                                                       redisMacOSAsyncCallback,
104:    if( !redisRunLoop->socketRef ) return freeRedisRunLoop(redisRunLoop);
106:    redisRunLoop->sourceRef = CFSocketCreateRunLoopSource(NULL, redisRunLoop->socketRef, 0);
107:    if( !redisRunLoop->sourceRef ) return freeRedisRunLoop(redisRunLoop);
109:    CFRunLoopAddSource(runLoop, redisRunLoop->sourceRef, kCFRunLoopDefaultMode);

deps/hiredis/adapters/libhv.h
5:#include "../hiredis.h"
8:typedef struct redisLibhvEvents {
11:} redisLibhvEvents;
13:static void redisLibhvHandleEvents(hio_t* io) {
14:    redisAsyncContext* context = (redisAsyncContext*)hevent_userdata(io);
18:        redisAsyncHandleRead(context);
21:        redisAsyncHandleWrite(context);
25:static void redisLibhvAddRead(void *privdata) {
26:    redisLibhvEvents* events = (redisLibhvEvents*)privdata;
27:    hio_add(events->io, redisLibhvHandleEvents, HV_READ);
30:static void redisLibhvDelRead(void *privdata) {
31:    redisLibhvEvents* events = (redisLibhvEvents*)privdata;
35:static void redisLibhvAddWrite(void *privdata) {
36:    redisLibhvEvents* events = (redisLibhvEvents*)privdata;
37:    hio_add(events->io, redisLibhvHandleEvents, HV_WRITE);
40:static void redisLibhvDelWrite(void *privdata) {
41:    redisLibhvEvents* events = (redisLibhvEvents*)privdata;
45:static void redisLibhvCleanup(void *privdata) {
46:    redisLibhvEvents* events = (redisLibhvEvents*)privdata;
57:static void redisLibhvTimeout(htimer_t* timer) {
59:    redisAsyncHandleTimeout((redisAsyncContext*)hevent_userdata(io));
62:static void redisLibhvSetTimeout(void *privdata, struct timeval tv) {
63:    redisLibhvEvents* events;
67:    events = (redisLibhvEvents*)privdata;
79:        events->timer = htimer_add(loop, redisLibhvTimeout, millis, 1);
87:static int redisLibhvAttach(redisAsyncContext* ac, hloop_t* loop) {
88:    redisContext *c = &(ac->c);
89:    redisLibhvEvents *events;
97:    events = (redisLibhvEvents*)hi_malloc(sizeof(*events));
113:    ac->ev.addRead  = redisLibhvAddRead;
114:    ac->ev.delRead  = redisLibhvDelRead;
115:    ac->ev.addWrite = redisLibhvAddWrite;
116:    ac->ev.delWrite = redisLibhvDelWrite;
117:    ac->ev.cleanup  = redisLibhvCleanup;
118:    ac->ev.scheduleTimer = redisLibhvSetTimeout;

deps/hiredis/adapters/ae.h
35:#include "../hiredis.h"
38:typedef struct redisAeEvents {
39:    redisAsyncContext *context;
43:} redisAeEvents;
45:static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
48:    redisAeEvents *e = (redisAeEvents*)privdata;
49:    redisAsyncHandleRead(e->context);
52:static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
55:    redisAeEvents *e = (redisAeEvents*)privdata;
56:    redisAsyncHandleWrite(e->context);
59:static void redisAeAddRead(void *privdata) {
60:    redisAeEvents *e = (redisAeEvents*)privdata;
64:        aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);
68:static void redisAeDelRead(void *privdata) {
69:    redisAeEvents *e = (redisAeEvents*)privdata;
77:static void redisAeAddWrite(void *privdata) {
78:    redisAeEvents *e = (redisAeEvents*)privdata;
82:        aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);
86:static void redisAeDelWrite(void *privdata) {
87:    redisAeEvents *e = (redisAeEvents*)privdata;
95:static void redisAeCleanup(void *privdata) {
96:    redisAeEvents *e = (redisAeEvents*)privdata;
97:    redisAeDelRead(privdata);
98:    redisAeDelWrite(privdata);
102:static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
103:    redisContext *c = &(ac->c);
104:    redisAeEvents *e;
111:    e = (redisAeEvents*)hi_malloc(sizeof(*e));
121:    ac->ev.addRead = redisAeAddRead;
122:    ac->ev.delRead = redisAeDelRead;
123:    ac->ev.addWrite = redisAeAddWrite;
124:    ac->ev.delWrite = redisAeDelWrite;
125:    ac->ev.cleanup = redisAeCleanup;

deps/hiredis/README.md
2:[![Build Status](https://github.com/redis/hiredis/actions/workflows/build.yml/badge.svg)](https://github.com/redis/hiredis/actions/workflows/build.yml)
4:**This Readme reflects the latest changed in the master branch. See [v1.0.0](https://github.com/redis/hiredis/tree/v1.0.0) for the Readme and documentation for the latest release ([API/ABI history](https://abi-laboratory.pro/?view=timeline&l=hiredis)).**
8:Hiredis is a minimalistic C client library for the [Redis](https://redis.io/) database.
20:Hiredis only supports the binary-safe Redis protocol, so you can use it with any
28:Almost all users will simply need to recompile their applications against the newer version of hiredis.
30:**NOTE**:  Hiredis can now return `nan` in addition to `-inf` and `inf` in a `REDIS_REPLY_DOUBLE`.
37:Version 1.0.2 is simply 1.0.0 with a fix for [CVE-2021-32765](https://github.com/redis/hiredis/security/advisories/GHSA-hfm9-39pp-55p2).  They are otherwise identical.
41:Version 1.0.0 marks the first stable release of Hiredis.
50:* `redisContext` has two additional members (`free_privdata`, and `privctx`).
51:* `redisOptions.timeout` has been renamed to `redisOptions.connect_timeout`, and we've added `redisOptions.command_timeout`.
52:* `redisReplyObjectFunctions.createArray` now takes `size_t` instead of `int` for its length parameter.
60:Change `redisReply.len` to `size_t`, as it denotes the the size of a string
68:Version 0.9.0 is a major overhaul of hiredis in every aspect. However, upgrading existing
69:code using hiredis should not be a big pain. The key thing to keep in mind when
70:upgrading is that hiredis >= 0.9.0 uses a `redisContext*` to keep state, in contrast to
78:redisContext *redisConnect(const char *ip, int port);
79:void *redisCommand(redisContext *c, const char *format, ...);
85:The function `redisConnect` is used to create a so-called `redisContext`. The
86:context is where Hiredis holds state for a connection. The `redisContext`
90:After trying to connect to Redis using `redisConnect` you should
94:redisContext *c = redisConnect("127.0.0.1", 6379);
100:        printf("Can't allocate redis context\n");
105:One can also use `redisConnectWithOptions` which takes a `redisOptions` argument
107:to change how the `redisContext` will be configured.
110:redisOptions opt = {0};
116:    REDIS_OPTIONS_SET_UNIX(&opt, "/tmp/redis.sock");
126:If a connection is lost, `int redisReconnect(redisContext *c)` can be used to restore the connection using the same endpoint and options as the given context.
128:### Configurable redisOptions flags
130:There are several flags you may set in the `redisOptions` struct to change default behavior.  You can specify the flags via the `redisOptions->options` member.
134:| REDIS\_OPT\_NONBLOCK | Tells hiredis to make a non-blocking connection. |
135:| REDIS\_OPT\_REUSEADDR | Tells hiredis to set the [SO_REUSEADDR](https://man7.org/linux/man-pages/man7/socket.7.html) socket option |
136:| REDIS\_OPT\_PREFER\_IPV4<br>REDIS\_OPT\_PREFER_IPV6<br>REDIS\_OPT\_PREFER\_IP\_UNSPEC | Informs hiredis to either prefer IPv4 or IPv6 when invoking [getaddrinfo](https://man7.org/linux/man-pages/man3/gai_strerror.3.html).  `REDIS_OPT_PREFER_IP_UNSPEC` will cause hiredis to specify `AF_UNSPEC` in the getaddrinfo call, which means both IPv4 and IPv6 addresses will be searched simultaneously.<br>Hiredis prefers IPv4 by default. |
137:| REDIS\_OPT\_NO\_PUSH\_AUTOFREE | Tells hiredis to not install the default RESP3 PUSH handler (which just intercepts and frees the replies).  This is useful in situations where you want to process these messages in-band. |
138:| REDIS\_OPT\_NOAUTOFREEREPLIES | **ASYNC**: tells hiredis not to automatically invoke `freeReplyObject` after executing the reply callback. |
139:| REDIS\_OPT\_NOAUTOFREE | **ASYNC**: Tells hiredis not to automatically free the `redisAsyncContext` on connection/communication failure, but only if the user makes an explicit call to `redisAsyncDisconnect` or `redisAsyncFree` |
141:*Note: A `redisContext` is not thread-safe.*
146:The values are not stored in the `redisContext`, so they are not automatically applied when reconnecting using `redisReconnect()`.
150:To configure these for an asyncronous context (see *Asynchronous API* below), use `ac->c` to get the redisContext out of an asyncRedisContext.
153:int redisEnableKeepAlive(redisContext *c);
154:int redisEnableKeepAliveWithInterval(redisContext *c, int interval);
165:int redisSetTcpUserTimeout(redisContext *c, unsigned int timeout);
176:`redisCommand`. This function takes a format similar to printf. In the simplest form,
179:reply = redisCommand(context, "SET foo bar");
185:reply = redisCommand(context, "SET foo %s", value);
191:reply = redisCommand(context, "SET foo %b", value, (size_t) valuelen);
193:Internally, Hiredis splits the command in different arguments and will
198:reply = redisCommand(context, "SET key:%s %s", myid, value);
203:The return value of `redisCommand` holds a reply when the command was
209:The standard replies that `redisCommand` are of the type `redisReply`. The
210:`type` field in the `redisReply` should be used to test what kind of reply
235:      `reply->elements`. Every element in the multi bulk reply is a `redisReply` object as well
241:Hiredis also supports every new `RESP3` data type which are as follows.  For more information about the protocol see the `RESP3` [specification.](https://github.com/antirez/RESP3/blob/master/spec.md)
269:      The number will be encoded as a string in the `str` member of `redisReply`.
280:**Important:** the current version of hiredis (1.0.0) frees replies when the
282:you use this API. The reply is cleaned up by hiredis _after_ the callback
289:void redisFree(redisContext *c);
296:Together with `redisCommand`, the function `redisCommandArgv` can be used to issue commands.
299:void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
306:The return value has the same semantic as `redisCommand`.
310:To explain how Hiredis supports pipelining in a blocking connection, there needs to be
313:When any of the functions in the `redisCommand` family is called, Hiredis first formats the
316:After the command is put in the output buffer, `redisGetReply` is called. This function has the
326:The function `redisGetReply` is exported as part of the Hiredis API and can be used when a reply
329:to the `redisCommand` family, apart from not returning a reply:
331:void redisAppendCommand(redisContext *c, const char *format, ...);
332:void redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
334:After calling either function one or more times, `redisGetReply` can be used to receive the
342:redisReply *reply;
343:redisAppendCommand(context,"SET foo bar");
344:redisAppendCommand(context,"GET foo");
345:redisGetReply(context,(void**)&reply); // reply for SET
347:redisGetReply(context,(void**)&reply); // reply for GET
352:reply = redisCommand(context,"SUBSCRIBE foo");
354:while(redisGetReply(context,(void *)&reply) == REDIS_OK) {
386:Hiredis comes with an asynchronous API that works easily with any event library.
387:Examples are bundled that show using Hiredis with [libev](http://software.schmorp.de/pkg/libev.html)
392:The function `redisAsyncConnect` can be used to establish a non-blocking connection to
393:Redis. It returns a pointer to the newly created `redisAsyncContext` struct. The `err` field
397:In case of error, it is the caller's responsibility to free the context using `redisAsyncFree()`
399:*Note: A `redisAsyncContext` is not thread-safe.*
406:    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
410:        redisAsyncFree(c);
416:        redisAsyncSetConnectCallback(c, appOnConnect);
417:        redisAsyncSetDisconnectCallback(c, appOnDisconnect);
430:void(const redisAsyncContext *c, int status);
449:/* Alternatively you can use redisAsyncSetConnectCallbackNC which will be passed a non-const
450:   redisAsyncContext* on invocation (e.g. allowing writes to the privdata member). */
451:int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn);
452:int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);
457:void appOnConnect(redisAsyncContext *c, int status)
471:void appOnDisconnect(redisAsyncContext *c, int status)
493:void(redisAsyncContext *c, void *reply, void *privdata);
500:int redisAsyncCommand(
501:  redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
503:int redisAsyncCommandArgv(
504:  redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
510:returned on calls to the `redisAsyncCommand` family.
530:void redisAsyncDisconnect(redisAsyncContext *ac);
540:void redisAsyncFree(redisAsyncContext *ac);
554:Hiredis comes with a reply parsing API that makes it easy for writing higher
559:redisReader *redisReaderCreate(void);
560:void redisReaderFree(redisReader *reader);
561:int redisReaderFeed(redisReader *reader, const char *buf, size_t len);
562:int redisReaderGetReply(redisReader *reader, void **reply);
564:The same set of functions are used internally by hiredis when creating a
570:The function `redisReaderCreate` creates a `redisReader` structure that holds a
574:buffer of the `redisReader` using `redisReaderFeed`. This function will make a
576:when `redisReaderGetReply` is called. This function returns an integer status
586:The function `redisReaderGetReply` creates `redisReply` and makes the function
587:argument `reply` point to the created `redisReply` variable. For instance, if
588:the response of type `REDIS_REPLY_STATUS` then the `str` field of `redisReply`
590:responsible for creating instances of the `redisReply` can be customized by
591:setting the `fn` field on the `redisReader` struct. This should be done
592:immediately after creating the `redisReader`.
594:For example, [hiredis-rb](https://github.com/pietern/hiredis-rb/blob/master/ext/hiredis_ext/reader.c)
600:normal Redis context, the redisReader structure uses a buffer in order to
622:By default the hiredis reply parser sets the maximum number of multi-bulk elements
641:When enabled, SSL/TLS support is built into extra `libhiredis_ssl.a` and
642:`libhiredis_ssl.so` static/dynamic libraries. This leaves the original libraries
650:#include <hiredis/hiredis.h>
651:#include <hiredis/hiredis_ssl.h>
654:You will also need to link against `libhiredis_ssl`, **in addition** to
655:`libhiredis` and add `-lssl -lcrypto` to satisfy its dependencies.
657:Hiredis implements SSL/TLS on top of its normal `redisContext` or
658:`redisAsyncContext`, so you will need to establish a connection first and then
661:#### Hiredis OpenSSL Wrappers
663:Before Hiredis can negotiate an SSL/TLS connection, it is necessary to
668:   call `redisInitiateSSL()`.
669:2. Work with a set of Hiredis-provided wrappers around OpenSSL, create a
670:   `redisSSLContext` object to hold configuration and use
671:   `redisInitiateSSLWithContext()` to initiate the SSL/TLS handshake.
674:/* An Hiredis SSL context. It holds SSL configuration and can be reused across
677:redisSSLContext *ssl_context;
682:redisSSLContextError ssl_error = REDIS_SSL_CTX_NONE;
689:redisInitOpenSSL();
692:ssl_context = redisCreateSSLContext(
697:    "redis.mydomain.com",   /* Server name to request (SNI), optional */
705:            redisSSLContextGetError(ssl_error) : "Unknown error");
711:c = redisConnect("localhost", 6443);
717:if (redisInitiateSSLWithContext(c, ssl_context) != REDIS_OK) {
726:Hiredis installs handlers on `redisContext` and `redisAsyncContext` by default, which will intercept and free any PUSH replies detected.  This means existing code will work as-is after upgrading to Redis 6 and switching to `RESP3`.
729:The callback prototypes differ between `redisContext` and `redisAsyncContext`.
731:#### redisContext
743:#### redisAsyncContext
745:void my_async_push_handler(redisAsyncContext *ac, void *reply) {
748:    /* Note:  Because async hiredis always frees replies, you should
756:1. Set `push_cb` or `async_push_cb` in the `redisOptions` struct and connect with `redisConnectWithOptions` or `redisAsyncConnectWithOptions`.
758:    redisOptions = {0};
761:    redisContext *context = redisConnectWithOptions(&options);
763:2.  Call `redisSetPushCallback` or `redisAsyncSetPushCallback` on a connected context.
765:    redisContext *context = redisConnect("127.0.0.1", 6379);
766:    redisSetPushCallback(context, my_push_handler);
769:    _Note `redisSetPushCallback` and `redisAsyncSetPushCallback` both return any currently configured handler,  making it easy to override and then return to the old value._
772:If you have a unique use-case where you don't want hiredis to automatically intercept and free PUSH replies, you will want to configure no handler at all.  This can be done in two ways.
773:1.  Set the `REDIS_OPT_NO_PUSH_AUTOFREE` flag in `redisOptions` and leave the callback function pointer `NULL`.
775:    redisOptions = {0};
778:    redisContext *context = redisConnectWithOptions(&options);
780:3.  Call `redisSetPushCallback` with `NULL` once connected.
782:    redisContext *context = redisConnect("127.0.0.1", 6379);
783:    redisSetPushCallback(context, NULL);
786:    _Note:  With no handler configured, calls to `redisCommand` may generate more than one reply, so this strategy is only applicable when there's some kind of blocking `redisGetReply()` loop (e.g. `MONITOR` or `SUBSCRIBE` workloads)._
790:Hiredis uses a pass-thru structure of function pointers defined in [alloc.h](https://github.com/redis/hiredis/blob/f5d25850/alloc.h#L41) that contain the currently configured allocation and deallocation functions.  By default they just point to libc (`malloc`, `calloc`, `realloc`, etc).
797:hiredisAllocFuncs myfuncs = {
806:hiredisAllocFuncs orig = hiredisSetAllocators(&myfuncs);
812:hiredisResetAllocators();
821:_Hiredis is released under the BSD license._

deps/hiredis/adapters/poll.h
10:/* Values to return from redisPollTick */
19:typedef struct redisPollEvents {
20:    redisAsyncContext *context;
21:    redisFD fd;
26:} redisPollEvents;
28:static double redisPollTimevalToDouble(struct timeval *tv) {
34:static double redisPollGetNow(void) {
38:    return redisPollTimevalToDouble(&tv);
52:static int redisPollTick(redisAsyncContext *ac, double timeout) {
59:    redisPollEvents *e = (redisPollEvents*)ac->ev.data;
94:            redisAsyncHandleRead(ac);
101:               by doing an redisAsyncDisconnect() */
103:                redisAsyncHandleWrite(ac);
111:        double now = redisPollGetNow();
115:            redisAsyncHandleTimeout(ac);
129:static void redisPollAddRead(void *data) {
130:    redisPollEvents *e = (redisPollEvents*)data;
134:static void redisPollDelRead(void *data) {
135:    redisPollEvents *e = (redisPollEvents*)data;
139:static void redisPollAddWrite(void *data) {
140:    redisPollEvents *e = (redisPollEvents*)data;
144:static void redisPollDelWrite(void *data) {
145:    redisPollEvents *e = (redisPollEvents*)data;
149:static void redisPollCleanup(void *data) {
150:    redisPollEvents *e = (redisPollEvents*)data;
159:static void redisPollScheduleTimer(void *data, struct timeval tv)
161:    redisPollEvents *e = (redisPollEvents*)data;
162:    double now = redisPollGetNow();
163:    e->deadline = now + redisPollTimevalToDouble(&tv);
166:static int redisPollAttach(redisAsyncContext *ac) {
167:    redisContext *c = &(ac->c);
168:    redisPollEvents *e;
175:    e = (redisPollEvents*)hi_malloc(sizeof(*e));
187:    ac->ev.addRead = redisPollAddRead;
188:    ac->ev.delRead = redisPollDelRead;
189:    ac->ev.addWrite = redisPollAddWrite;
190:    ac->ev.delWrite = redisPollDelWrite;
191:    ac->ev.scheduleTimer = redisPollScheduleTimer;
192:    ac->ev.cleanup = redisPollCleanup;

deps/hiredis/adapters/qt.h
81:        int setContext(redisAsyncContext * ac) {
126:        void read() { redisAsyncHandleRead(m_ctx); }
127:        void write() { redisAsyncHandleWrite(m_ctx); }
130:        redisAsyncContext * m_ctx;

deps/hiredis/adapters/libuv.h
5:#include "../hiredis.h"
9:typedef struct redisLibuvEvents {
10:    redisAsyncContext* context;
14:} redisLibuvEvents;
17:static void redisLibuvPoll(uv_poll_t* handle, int status, int events) {
18:    redisLibuvEvents* p = (redisLibuvEvents*)handle->data;
22:        redisAsyncHandleRead(p->context);
25:        redisAsyncHandleWrite(p->context);
30:static void redisLibuvAddRead(void *privdata) {
31:    redisLibuvEvents* p = (redisLibuvEvents*)privdata;
39:    uv_poll_start(&p->handle, p->events, redisLibuvPoll);
43:static void redisLibuvDelRead(void *privdata) {
44:    redisLibuvEvents* p = (redisLibuvEvents*)privdata;
49:        uv_poll_start(&p->handle, p->events, redisLibuvPoll);
56:static void redisLibuvAddWrite(void *privdata) {
57:    redisLibuvEvents* p = (redisLibuvEvents*)privdata;
65:    uv_poll_start(&p->handle, p->events, redisLibuvPoll);
69:static void redisLibuvDelWrite(void *privdata) {
70:    redisLibuvEvents* p = (redisLibuvEvents*)privdata;
75:        uv_poll_start(&p->handle, p->events, redisLibuvPoll);
82:    redisLibuvEvents* p = (redisLibuvEvents*)handle->data;
92:    redisLibuvEvents* p = (redisLibuvEvents*)handle->data;
105:static void redisLibuvTimeout(uv_timer_t *timer, int status) {
108:static void redisLibuvTimeout(uv_timer_t *timer) {
110:    redisLibuvEvents *e = (redisLibuvEvents*)timer->data;
111:    redisAsyncHandleTimeout(e->context);
114:static void redisLibuvSetTimeout(void *privdata, struct timeval tv) {
115:    redisLibuvEvents* p = (redisLibuvEvents*)privdata;
127:    uv_timer_start(&p->timer, redisLibuvTimeout, millsec, 0);
130:static void redisLibuvCleanup(void *privdata) {
131:    redisLibuvEvents* p = (redisLibuvEvents*)privdata;
141:static int redisLibuvAttach(redisAsyncContext* ac, uv_loop_t* loop) {
142:    redisContext *c = &(ac->c);
148:    ac->ev.addRead        = redisLibuvAddRead;
149:    ac->ev.delRead        = redisLibuvDelRead;
150:    ac->ev.addWrite       = redisLibuvAddWrite;
151:    ac->ev.delWrite       = redisLibuvDelWrite;
152:    ac->ev.cleanup        = redisLibuvCleanup;
153:    ac->ev.scheduleTimer  = redisLibuvSetTimeout;
155:    redisLibuvEvents* p = (redisLibuvEvents*)hi_malloc(sizeof(*p));

deps/hiredis/adapters/libevent.h
34:#include "../hiredis.h"
40:typedef struct redisLibeventEvents {
41:    redisAsyncContext *context;
47:} redisLibeventEvents;
49:static void redisLibeventDestroy(redisLibeventEvents *e) {
53:static void redisLibeventHandler(evutil_socket_t fd, short event, void *arg) {
55:    redisLibeventEvents *e = (redisLibeventEvents*)arg;
59:        redisLibeventDestroy(e);\
64:        redisAsyncHandleTimeout(e->context);
69:        redisAsyncHandleRead(e->context);
74:        redisAsyncHandleWrite(e->context);
82:static void redisLibeventUpdate(void *privdata, short flag, int isRemove) {
83:    redisLibeventEvents *e = (redisLibeventEvents *)privdata;
102:                 redisLibeventHandler, privdata);
106:static void redisLibeventAddRead(void *privdata) {
107:    redisLibeventUpdate(privdata, EV_READ, 0);
110:static void redisLibeventDelRead(void *privdata) {
111:    redisLibeventUpdate(privdata, EV_READ, 1);
114:static void redisLibeventAddWrite(void *privdata) {
115:    redisLibeventUpdate(privdata, EV_WRITE, 0);
118:static void redisLibeventDelWrite(void *privdata) {
119:    redisLibeventUpdate(privdata, EV_WRITE, 1);
122:static void redisLibeventCleanup(void *privdata) {
123:    redisLibeventEvents *e = (redisLibeventEvents*)privdata;
134:        redisLibeventDestroy(e);
138:static void redisLibeventSetTimeout(void *privdata, struct timeval tv) {
139:    redisLibeventEvents *e = (redisLibeventEvents *)privdata;
143:    redisLibeventUpdate(e, flags, 0);
146:static int redisLibeventAttach(redisAsyncContext *ac, struct event_base *base) {
147:    redisContext *c = &(ac->c);
148:    redisLibeventEvents *e;
155:    e = (redisLibeventEvents*)hi_calloc(1, sizeof(*e));
162:    ac->ev.addRead = redisLibeventAddRead;
163:    ac->ev.delRead = redisLibeventDelRead;
164:    ac->ev.addWrite = redisLibeventAddWrite;
165:    ac->ev.delWrite = redisLibeventDelWrite;
166:    ac->ev.cleanup = redisLibeventCleanup;
167:    ac->ev.scheduleTimer = redisLibeventSetTimeout;
171:    e->ev = event_new(base, c->fd, EV_READ | EV_WRITE, redisLibeventHandler, e);

deps/hiredis/Makefile
1:# Hiredis Makefile
6:OBJ=alloc.o net.o hiredis.o sds.o async.o read.o sockcompat.o
7:EXAMPLES=hiredis-example hiredis-example-libevent hiredis-example-libev hiredis-example-glib hiredis-example-push hiredis-example-poll
8:TESTS=hiredis-test
9:LIBNAME=libhiredis
10:PKGCONFNAME=hiredis.pc
12:HIREDIS_MAJOR=$(shell grep HIREDIS_MAJOR hiredis.h | awk '{print $$3}')
13:HIREDIS_MINOR=$(shell grep HIREDIS_MINOR hiredis.h | awk '{print $$3}')
14:HIREDIS_PATCH=$(shell grep HIREDIS_PATCH hiredis.h | awk '{print $$3}')
15:HIREDIS_SONAME=$(shell grep HIREDIS_SONAME hiredis.h | awk '{print $$3}')
19:INCLUDE_PATH?=include/hiredis
26:# redis-server configuration used for testing
28:REDIS_SERVER=redis-server
31:	pidfile /tmp/hiredis-test-redis.pid
34:	unixsocket /tmp/hiredis-test-redis.sock
59:SSL_LIBNAME=libhiredis_ssl
60:SSL_PKGCONFNAME=hiredis_ssl.pc
72:  EXAMPLES+=hiredis-example-ssl hiredis-example-libevent-ssl
145:all: dynamic static hiredis-test pkgconfig
155:async.o: async.c fmacros.h alloc.h async.h hiredis.h read.h sds.h net.h dict.c dict.h win32.h async_private.h
157:hiredis.o: hiredis.c fmacros.h hiredis.h read.h sds.h alloc.h net.h async.h win32.h
158:net.o: net.c fmacros.h net.h hiredis.h read.h sds.h alloc.h sockcompat.h win32.h
162:test.o: test.c fmacros.h hiredis.h read.h sds.h alloc.h net.h sockcompat.h win32.h
177:$(SSL_OBJ): ssl.c hiredis.h read.h sds.h alloc.h async.h win32.h async_private.h
181:hiredis-example-libevent: examples/example-libevent.c adapters/libevent.h $(STLIBNAME)
184:hiredis-example-libevent-ssl: examples/example-libevent-ssl.c adapters/libevent.h $(STLIBNAME) $(SSL_STLIBNAME)
187:hiredis-example-libev: examples/example-libev.c adapters/libev.h $(STLIBNAME)
190:hiredis-example-libhv: examples/example-libhv.c adapters/libhv.h $(STLIBNAME)
193:hiredis-example-glib: examples/example-glib.c adapters/glib.h $(STLIBNAME)
196:hiredis-example-ivykis: examples/example-ivykis.c adapters/ivykis.h $(STLIBNAME)
199:hiredis-example-macosx: examples/example-macosx.c adapters/macosx.h $(STLIBNAME)
202:hiredis-example-ssl: examples/example-ssl.c $(STLIBNAME) $(SSL_STLIBNAME)
205:hiredis-example-poll: examples/example-poll.c adapters/poll.h $(STLIBNAME)
209:hiredis-example-ae:
210:	@echo "Please specify AE_DIR (e.g. <redis repository>/src)"
213:hiredis-example-ae: examples/example-ae.c adapters/ae.h $(STLIBNAME)
219:hiredis-example-libuv: examples/example-libuv.c adapters/libuv.h $(STLIBNAME)
223:hiredis-example-libuv: examples/example-libuv.c adapters/libuv.h $(STLIBNAME)
228:hiredis-example-qt:
232:hiredis-example-qt: examples/example-qt.cpp adapters/qt.h $(STLIBNAME)
240:hiredis-example: examples/example.c $(STLIBNAME)
243:hiredis-example-push: examples/example-push.c $(STLIBNAME)
257:hiredis-test: test.o $(TEST_LIBS)
260:hiredis-%: %.o $(STLIBNAME)
263:test: hiredis-test
264:	./hiredis-test
266:check: hiredis-test
273:	rm -rf $(DYLIBNAME) $(STLIBNAME) $(SSL_DYLIBNAME) $(SSL_STLIBNAME) $(TESTS) $(PKGCONFNAME) examples/hiredis-example* *.o *.gcda *.gcno *.gcov
280:$(PKGCONFNAME): hiredis.h
288:	@echo Name: hiredis >> $@
291:	@echo Libs: -L\$${libdir} -lhiredis >> $@
294:$(SSL_PKGCONFNAME): hiredis_ssl.h
302:	@echo Name: hiredis_ssl >> $@
303:	@echo Description: SSL Support for hiredis. >> $@
305:	@echo Requires: hiredis >> $@
306:	@echo Libs: -L\$${libdir} -lhiredis_ssl >> $@
311:	$(INSTALL) hiredis.h async.h read.h sds.h alloc.h sockcompat.h $(INSTALL_INCLUDE_PATH)
321:	$(INSTALL) hiredis_ssl.h $(INSTALL_INCLUDE_PATH)
347:	lcov -d . -c --exclude '/usr*' -o tmp/lcov/hiredis.info
348:	lcov -q -l tmp/lcov/hiredis.info
349:	genhtml --legend -q -o tmp/lcov/report tmp/lcov/hiredis.info

deps/hiredis/adapters/glib.h
6:#include "../hiredis.h"
12:    redisAsyncContext *ac;
17:redis_source_add_read (gpointer data)
26:redis_source_del_read (gpointer data)
35:redis_source_add_write (gpointer data)
44:redis_source_del_write (gpointer data)
53:redis_source_cleanup (gpointer data)
59:    redis_source_del_read(source);
60:    redis_source_del_write(source);
72:redis_source_prepare (GSource *source,
75:    RedisSource *redis = (RedisSource *)source;
77:    return !!(redis->poll_fd.events & redis->poll_fd.revents);
81:redis_source_check (GSource *source)
83:    RedisSource *redis = (RedisSource *)source;
84:    return !!(redis->poll_fd.events & redis->poll_fd.revents);
88:redis_source_dispatch (GSource      *source,
92:    RedisSource *redis = (RedisSource *)source;
94:    if ((redis->poll_fd.revents & G_IO_OUT)) {
95:        redisAsyncHandleWrite(redis->ac);
96:        redis->poll_fd.revents &= ~G_IO_OUT;
99:    if ((redis->poll_fd.revents & G_IO_IN)) {
100:        redisAsyncHandleRead(redis->ac);
101:        redis->poll_fd.revents &= ~G_IO_IN;
112:redis_source_finalize (GSource *source)
114:    RedisSource *redis = (RedisSource *)source;
116:    if (redis->poll_fd.fd >= 0) {
117:        g_source_remove_poll(source, &redis->poll_fd);
118:        redis->poll_fd.fd = -1;
123:redis_source_new (redisAsyncContext *ac)
126:        .prepare  = redis_source_prepare,
127:        .check     = redis_source_check,
128:        .dispatch = redis_source_dispatch,
129:        .finalize = redis_source_finalize,
131:    redisContext *c = &ac->c;
146:    ac->ev.addRead = redis_source_add_read;
147:    ac->ev.delRead = redis_source_del_read;
148:    ac->ev.addWrite = redis_source_add_write;
149:    ac->ev.delWrite = redis_source_del_write;
150:    ac->ev.cleanup = redis_source_cleanup;

deps/hiredis/adapters/libev.h
36:#include "../hiredis.h"
39:typedef struct redisLibevEvents {
40:    redisAsyncContext *context;
45:} redisLibevEvents;
47:static void redisLibevReadEvent(EV_P_ ev_io *watcher, int revents) {
53:    redisLibevEvents *e = (redisLibevEvents*)watcher->data;
54:    redisAsyncHandleRead(e->context);
57:static void redisLibevWriteEvent(EV_P_ ev_io *watcher, int revents) {
63:    redisLibevEvents *e = (redisLibevEvents*)watcher->data;
64:    redisAsyncHandleWrite(e->context);
67:static void redisLibevAddRead(void *privdata) {
68:    redisLibevEvents *e = (redisLibevEvents*)privdata;
78:static void redisLibevDelRead(void *privdata) {
79:    redisLibevEvents *e = (redisLibevEvents*)privdata;
89:static void redisLibevAddWrite(void *privdata) {
90:    redisLibevEvents *e = (redisLibevEvents*)privdata;
100:static void redisLibevDelWrite(void *privdata) {
101:    redisLibevEvents *e = (redisLibevEvents*)privdata;
111:static void redisLibevStopTimer(void *privdata) {
112:    redisLibevEvents *e = (redisLibevEvents*)privdata;
119:static void redisLibevCleanup(void *privdata) {
120:    redisLibevEvents *e = (redisLibevEvents*)privdata;
121:    redisLibevDelRead(privdata);
122:    redisLibevDelWrite(privdata);
123:    redisLibevStopTimer(privdata);
127:static void redisLibevTimeout(EV_P_ ev_timer *timer, int revents) {
132:    redisLibevEvents *e = (redisLibevEvents*)timer->data;
133:    redisAsyncHandleTimeout(e->context);
136:static void redisLibevSetTimeout(void *privdata, struct timeval tv) {
137:    redisLibevEvents *e = (redisLibevEvents*)privdata;
143:        ev_init(&e->timer, redisLibevTimeout);
151:static int redisLibevAttach(EV_P_ redisAsyncContext *ac) {
152:    redisContext *c = &(ac->c);
153:    redisLibevEvents *e;
160:    e = (redisLibevEvents*)hi_calloc(1, sizeof(*e));
174:    ac->ev.addRead = redisLibevAddRead;
175:    ac->ev.delRead = redisLibevDelRead;
176:    ac->ev.addWrite = redisLibevAddWrite;
177:    ac->ev.delWrite = redisLibevDelWrite;
178:    ac->ev.cleanup = redisLibevCleanup;
179:    ac->ev.scheduleTimer = redisLibevSetTimeout;
183:    ev_io_init(&e->rev,redisLibevReadEvent,c->fd,EV_READ);
184:    ev_io_init(&e->wev,redisLibevWriteEvent,c->fd,EV_WRITE);

deps/hiredis/hiredis_ssl-config.cmake.in
3:set_and_check(hiredis_ssl_INCLUDEDIR "@PACKAGE_INCLUDE_INSTALL_DIR@")
8:IF (NOT TARGET hiredis::hiredis_ssl)
9:	INCLUDE(${CMAKE_CURRENT_LIST_DIR}/hiredis_ssl-targets.cmake)
12:SET(hiredis_ssl_LIBRARIES hiredis::hiredis_ssl)
13:SET(hiredis_ssl_INCLUDE_DIRS ${hiredis_ssl_INCLUDEDIR})
15:check_required_components(hiredis_ssl)

deps/hiredis/hiredis.h
54: * least significant bit of the flags field in redisContext. */
107:struct redisAsyncContext;
108:struct redisContext;
111:#define redisIsPushReply(r) (((redisReply*)(r))->type == REDIS_REPLY_PUSH)
112:typedef void (redisPushFn)(void *, void *);
113:typedef void (redisAsyncPushFn)(struct redisAsyncContext *, void *);
119:/* This is the reply object returned by redisCommand() */
120:typedef struct redisReply {
131:    struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
132:} redisReply;
134:redisReader *redisReaderCreate(void);
136:/* Function to free the reply objects hiredis returns by default. */
140:int redisvFormatCommand(char **target, const char *format, va_list ap);
141:int redisFormatCommand(char **target, const char *format, ...);
142:long long redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen);
143:long long redisFormatSdsCommandArgv(hisds *target, int argc, const char ** argv, const size_t *argvlen);
144:void redisFreeCommand(char *cmd);
145:void redisFreeSdsCommand(hisds cmd);
147:enum redisConnectionType {
153:struct redisSsl;
174:typedef int redisFD;
178:typedef unsigned long long redisFD; /* SOCKET = 64-bit UINT_PTR */
180:typedef unsigned long redisFD;      /* SOCKET = 32-bit UINT_PTR */
182:#define REDIS_INVALID_FD ((redisFD)(~0)) /* INVALID_SOCKET */
196:     * updated at runtime with redisSetTimeout/redisAsyncSetTimeout. */
208:         * use this field to have hiredis operate an already-open
210:        redisFD fd;
218:    redisPushFn *push_cb;
219:    redisAsyncPushFn *async_push_cb;
220:} redisOptions;
241:typedef struct redisContextFuncs {
242:    void (*close)(struct redisContext *);
244:    void (*async_read)(struct redisAsyncContext *);
245:    void (*async_write)(struct redisAsyncContext *);
251:    ssize_t (*read)(struct redisContext *, char *, size_t);
252:    ssize_t (*write)(struct redisContext *);
253:} redisContextFuncs;
257:typedef struct redisContext {
258:    const redisContextFuncs *funcs;   /* Function table */
262:    redisFD fd;
265:    redisReader *reader; /* Protocol reader */
267:    enum redisConnectionType connection_type;
286:     * context to a given redisContext.  Not used by hiredis. */
290:    /* Internal context pointer presently used by hiredis to manage
295:    redisPushFn *push_cb;
296:} redisContext;
298:redisContext *redisConnectWithOptions(const redisOptions *options);
299:redisContext *redisConnect(const char *ip, int port);
300:redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv);
301:redisContext *redisConnectNonBlock(const char *ip, int port);
302:redisContext *redisConnectBindNonBlock(const char *ip, int port,
304:redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
306:redisContext *redisConnectUnix(const char *path);
307:redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv);
308:redisContext *redisConnectUnixNonBlock(const char *path);
309:redisContext *redisConnectFd(redisFD fd);
320:int redisReconnect(redisContext *c);
322:redisPushFn *redisSetPushCallback(redisContext *c, redisPushFn *fn);
323:int redisSetTimeout(redisContext *c, const struct timeval tv);
324:int redisEnableKeepAlive(redisContext *c);
325:int redisEnableKeepAliveWithInterval(redisContext *c, int interval);
326:int redisSetTcpUserTimeout(redisContext *c, unsigned int timeout);
327:void redisFree(redisContext *c);
328:redisFD redisFreeKeepFd(redisContext *c);
329:int redisBufferRead(redisContext *c);
330:int redisBufferWrite(redisContext *c, int *done);
336:int redisGetReply(redisContext *c, void **reply);
337:int redisGetReplyFromReader(redisContext *c, void **reply);
341:int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len);
345:int redisvAppendCommand(redisContext *c, const char *format, va_list ap);
346:int redisAppendCommand(redisContext *c, const char *format, ...);
347:int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
350: * redisAppendCommand, followed by redisGetReply. The function will return
353: * only redisAppendCommand and will always return NULL. */
354:void *redisvCommand(redisContext *c, const char *format, va_list ap);
355:void *redisCommand(redisContext *c, const char *format, ...);
356:void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);

deps/hiredis/adapters/libsdevent.h
4:#include "../hiredis.h"
10:typedef struct redisLibsdeventEvents {
11:    redisAsyncContext *context;
18:} redisLibsdeventEvents;
20:static void redisLibsdeventDestroy(redisLibsdeventEvents *e) {
31:static int redisLibsdeventTimeoutHandler(sd_event_source *s, uint64_t usec, void *userdata) {
34:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
35:    redisAsyncHandleTimeout(e->context);
39:static int redisLibsdeventHandler(sd_event_source *s, int fd, uint32_t event, void *userdata) {
42:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
46:        redisLibsdeventDestroy(e);\
51:        redisAsyncHandleRead(e->context);
56:        redisAsyncHandleWrite(e->context);
66:static void redisLibsdeventAddRead(void *userdata) {
67:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
78:        sd_event_add_io(e->event, &e->fdSource, e->fd, e->flags, redisLibsdeventHandler, e);
82:static void redisLibsdeventDelRead(void *userdata) {
83:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
94:static void redisLibsdeventAddWrite(void *userdata) {
95:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
106:        sd_event_add_io(e->event, &e->fdSource, e->fd, e->flags, redisLibsdeventHandler, e);
110:static void redisLibsdeventDelWrite(void *userdata) {
111:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
122:static void redisLibsdeventCleanup(void *userdata) {
123:    redisLibsdeventEvents *e = (redisLibsdeventEvents*)userdata;
132:        redisLibsdeventDestroy(e);
136:static void redisLibsdeventSetTimeout(void *userdata, struct timeval tv) {
137:    redisLibsdeventEvents *e = (redisLibsdeventEvents *)userdata;
141:        sd_event_add_time_relative(e->event, &e->timerSource, CLOCK_MONOTONIC, usec, 1, redisLibsdeventTimeoutHandler, e);
147:static int redisLibsdeventAttach(redisAsyncContext *ac, struct sd_event *event) {
148:    redisContext *c = &(ac->c);
149:    redisLibsdeventEvents *e;
156:    e = (redisLibsdeventEvents*)hi_calloc(1, sizeof(*e));
167:    ac->ev.addRead = redisLibsdeventAddRead;
168:    ac->ev.delRead = redisLibsdeventDelRead;
169:    ac->ev.addWrite = redisLibsdeventAddWrite;
170:    ac->ev.delWrite = redisLibsdeventDelWrite;
171:    ac->ev.cleanup = redisLibsdeventCleanup;
172:    ac->ev.scheduleTimer = redisLibsdeventSetTimeout;

deps/hiredis/adapters/redismoduleapi.h
4:#include "redismodule.h"
7:#include "../hiredis.h"
11:typedef struct redisModuleEvents {
12:    redisAsyncContext *context;
18:} redisModuleEvents;
20:static inline void redisModuleReadEvent(int fd, void *privdata, int mask) {
24:    redisModuleEvents *e = (redisModuleEvents*)privdata;
25:    redisAsyncHandleRead(e->context);
28:static inline void redisModuleWriteEvent(int fd, void *privdata, int mask) {
32:    redisModuleEvents *e = (redisModuleEvents*)privdata;
33:    redisAsyncHandleWrite(e->context);
36:static inline void redisModuleAddRead(void *privdata) {
37:    redisModuleEvents *e = (redisModuleEvents*)privdata;
40:        RedisModule_EventLoopAdd(e->fd, REDISMODULE_EVENTLOOP_READABLE, redisModuleReadEvent, e);
44:static inline void redisModuleDelRead(void *privdata) {
45:    redisModuleEvents *e = (redisModuleEvents*)privdata;
52:static inline void redisModuleAddWrite(void *privdata) {
53:    redisModuleEvents *e = (redisModuleEvents*)privdata;
56:        RedisModule_EventLoopAdd(e->fd, REDISMODULE_EVENTLOOP_WRITABLE, redisModuleWriteEvent, e);
60:static inline void redisModuleDelWrite(void *privdata) {
61:    redisModuleEvents *e = (redisModuleEvents*)privdata;
68:static inline void redisModuleStopTimer(void *privdata) {
69:    redisModuleEvents *e = (redisModuleEvents*)privdata;
76:static inline void redisModuleCleanup(void *privdata) {
77:    redisModuleEvents *e = (redisModuleEvents*)privdata;
78:    redisModuleDelRead(privdata);
79:    redisModuleDelWrite(privdata);
80:    redisModuleStopTimer(privdata);
84:static inline void redisModuleTimeout(RedisModuleCtx *ctx, void *privdata) {
87:    redisModuleEvents *e = (redisModuleEvents*)privdata;
89:    redisAsyncHandleTimeout(e->context);
92:static inline void redisModuleSetTimeout(void *privdata, struct timeval tv) {
93:    redisModuleEvents* e = (redisModuleEvents*)privdata;
95:    redisModuleStopTimer(privdata);
98:    e->timer_id = RedisModule_CreateTimer(e->module_ctx, millis, redisModuleTimeout, e);
103:static inline int redisModuleCompatibilityCheck(void) {
113:static inline int redisModuleAttach(redisAsyncContext *ac, RedisModuleCtx *module_ctx) {
114:    redisContext *c = &(ac->c);
115:    redisModuleEvents *e;
122:    e = (redisModuleEvents*)hi_malloc(sizeof(*e));
133:    ac->ev.addRead = redisModuleAddRead;
134:    ac->ev.delRead = redisModuleDelRead;
135:    ac->ev.addWrite = redisModuleAddWrite;
136:    ac->ev.delWrite = redisModuleDelWrite;
137:    ac->ev.cleanup = redisModuleCleanup;
138:    ac->ev.scheduleTimer = redisModuleSetTimeout;

deps/hiredis/sockcompat.c
264:int win32_redisKeepAlive(SOCKET sockfd, int interval_ms) {

deps/hiredis/net.h
1:/* Extracted from anet.c to work properly with Hiredis error reporting.
38:#include "hiredis.h"
40:void redisNetClose(redisContext *c);
41:ssize_t redisNetRead(redisContext *c, char *buf, size_t bufcap);
42:ssize_t redisNetWrite(redisContext *c);
44:int redisCheckSocketError(redisContext *c);
45:int redisContextSetTimeout(redisContext *c, const struct timeval tv);
46:int redisContextConnectTcp(redisContext *c, const char *addr, int port, const struct timeval *timeout);
47:int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
50:int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout);
51:int redisKeepAlive(redisContext *c, int interval);
52:int redisCheckConnectDone(redisContext *c, int *completed);
54:int redisSetTcpNoDelay(redisContext *c);
55:int redisContextSetTcpUserTimeout(redisContext *c, unsigned int timeout);

deps/hiredis/ssl.c
33:#include "hiredis.h"
60:#include "hiredis_ssl.h"
64:void __redisSetError(redisContext *c, int type, const char *str);
66:struct redisSSLContext {
67:    /* Associated OpenSSL SSL_CTX as created by redisCreateSSLContext() */
75:typedef struct redisSSL {
95:} redisSSL;
98:redisContextFuncs redisContextSSLFuncs;
168:int redisInitOpenSSL(void)
179: * redisSSLContext helper context destruction.
182:const char *redisSSLContextGetError(redisSSLContextError error)
206:void redisFreeSSLContext(redisSSLContext *ctx)
226: * redisSSLContext helper context initialization.
229:redisSSLContext *redisCreateSSLContext(const char *cacert_filename, const char *capath,
231:        const char *server_name, redisSSLContextError *error)
233:    redisSSLOptions options = {
242:    return redisCreateSSLContextWithOptions(&options, error);
245:redisSSLContext *redisCreateSSLContextWithOptions(redisSSLOptions *options, redisSSLContextError *error) {
257:    redisSSLContext *ctx = hi_calloc(1, sizeof(redisSSLContext));
346:    redisFreeSSLContext(ctx);
355:static int redisSSLConnect(redisContext *c, SSL *ssl) {
357:        __redisSetError(c, REDIS_ERR_OTHER, "redisContext was already associated");
361:    redisSSL *rssl = hi_calloc(1, sizeof(redisSSL));
363:        __redisSetError(c, REDIS_ERR_OOM, "Out of memory");
367:    c->funcs = &redisContextSSLFuncs;
397:        __redisSetError(c, REDIS_ERR_IO, err);
405: * A wrapper around redisSSLConnect() for users who manage their own context and
409:int redisInitiateSSL(redisContext *c, SSL *ssl) {
410:    return redisSSLConnect(c, ssl);
414: * A wrapper around redisSSLConnect() for users who use redisSSLContext and don't
418:int redisInitiateSSLWithContext(redisContext *c, redisSSLContext *redis_ssl_ctx)
420:    if (!c || !redis_ssl_ctx)
423:    /* We want to verify that redisSSLConnect() won't fail on this, as it will
429:    SSL *ssl = SSL_new(redis_ssl_ctx->ssl_ctx);
431:        __redisSetError(c, REDIS_ERR_OTHER, "Couldn't create new SSL instance");
435:    if (redis_ssl_ctx->server_name) {
436:        if (!SSL_set_tlsext_host_name(ssl, redis_ssl_ctx->server_name)) {
437:            __redisSetError(c, REDIS_ERR_OTHER, "Failed to set server_name/SNI");
442:    if (redisSSLConnect(c, ssl) != REDIS_OK) {
454:static int maybeCheckWant(redisSSL *rssl, int rv) {
471: * Implementation of redisContextFuncs for SSL connections.
474:static void redisSSLFree(void *privctx){
475:    redisSSL *rsc = privctx;
485:static ssize_t redisSSLRead(redisContext *c, char *buf, size_t bufcap) {
486:    redisSSL *rssl = c->privctx;
492:        __redisSetError(c, REDIS_ERR_EOF, "Server closed the connection");
510:                __redisSetError(c, REDIS_ERR_IO, msg);
521:            __redisSetError(c, REDIS_ERR_IO, NULL);
527:static ssize_t redisSSLWrite(redisContext *c) {
528:    redisSSL *rssl = c->privctx;
542:            __redisSetError(c, REDIS_ERR_IO, NULL);
549:static void redisSSLAsyncRead(redisAsyncContext *ac) {
551:    redisSSL *rssl = ac->c.privctx;
552:    redisContext *c = &ac->c;
561:        rv = redisBufferWrite(c, &done);
563:            __redisAsyncDisconnect(ac);
570:    rv = redisBufferRead(c);
572:        __redisAsyncDisconnect(ac);
575:        redisProcessCallbacks(ac);
579:static void redisSSLAsyncWrite(redisAsyncContext *ac) {
581:    redisSSL *rssl = ac->c.privctx;
582:    redisContext *c = &ac->c;
585:    rv = redisBufferWrite(c, &done);
587:        __redisAsyncDisconnect(ac);
609:redisContextFuncs redisContextSSLFuncs = {
610:    .close = redisNetClose,
611:    .free_privctx = redisSSLFree,
612:    .async_read = redisSSLAsyncRead,
613:    .async_write = redisSSLAsyncWrite,
614:    .read = redisSSLRead,
615:    .write = redisSSLWrite

deps/hiredis/fuzzing/format_command_fuzzer.c
36:#include "hiredis.h"
51:    if (redisFormatCommand(&cmd, new_str) != -1)

deps/hiredis/sdscompat.h
34: * This simple file maps sds types and calls to their unique hiredis symbol names.
35: * It's useful when we build Hiredis as a dependency of Redis and want to call
36: * Hiredis' sds symbols rather than the ones built into Redis, as the libraries

deps/hiredis/CMakeLists.txt
4:OPTION(ENABLE_SSL "Build hiredis_ssl for SSL support" OFF)
7:OPTION(ENABLE_EXAMPLES "Enable building hiredis examples" OFF)
12:  FILE(STRINGS "${CMAKE_CURRENT_SOURCE_DIR}/hiredis.h"
24:PROJECT(hiredis LANGUAGES "C" VERSION "${VERSION}")
27:# Hiredis requires C99
31:SET(hiredis_sources
34:    hiredis.c
40:SET(hiredis_sources ${hiredis_sources})
46:ADD_LIBRARY(hiredis ${hiredis_sources})
47:ADD_LIBRARY(hiredis::hiredis ALIAS hiredis)
48:set(hiredis_export_name hiredis CACHE STRING "Name of the exported target")
49:set_target_properties(hiredis PROPERTIES EXPORT_NAME ${hiredis_export_name})
51:SET_TARGET_PROPERTIES(hiredis
55:    SET_TARGET_PROPERTIES(hiredis
59:    TARGET_LINK_LIBRARIES(hiredis PUBLIC ws2_32 crypt32)
61:    TARGET_LINK_LIBRARIES(hiredis PUBLIC m)
63:    TARGET_LINK_LIBRARIES(hiredis PUBLIC socket)
66:TARGET_INCLUDE_DIRECTORIES(hiredis PUBLIC $<INSTALL_INTERFACE:include> $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)
68:CONFIGURE_FILE(hiredis.pc.in hiredis.pc @ONLY)
72:Hiredis is a minimalistic C client library for the Redis database.
84:Hiredis only supports the binary-safe Redis protocol, so you can use it with any Redis \
89:set(CPACK_PACKAGE_HOMEPAGE_URL "https://github.com/redis/hiredis")
96:INSTALL(TARGETS hiredis
97:    EXPORT hiredis-targets
103:    INSTALL(FILES $<TARGET_PDB_FILE:hiredis>
109:INSTALL(FILES hiredis.targets
112:INSTALL(FILES hiredis.h read.h sds.h async.h alloc.h sockcompat.h
113:    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/hiredis)
116:    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/hiredis)
118:INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/hiredis.pc
121:export(EXPORT hiredis-targets
122:    FILE "${CMAKE_CURRENT_BINARY_DIR}/hiredis-targets.cmake"
123:    NAMESPACE hiredis::)
126:    SET(CMAKE_CONF_INSTALL_DIR share/hiredis)
128:    SET(CMAKE_CONF_INSTALL_DIR ${CMAKE_INSTALL_LIBDIR}/cmake/hiredis)
132:write_basic_package_version_file("${CMAKE_CURRENT_BINARY_DIR}/hiredis-config-version.cmake"
134:configure_package_config_file(hiredis-config.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/hiredis-config.cmake
138:INSTALL(EXPORT hiredis-targets
139:        FILE hiredis-targets.cmake
140:        NAMESPACE hiredis::
143:INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/hiredis-config.cmake
144:              ${CMAKE_CURRENT_BINARY_DIR}/hiredis-config-version.cmake
155:    SET(hiredis_ssl_sources
157:    ADD_LIBRARY(hiredis_ssl ${hiredis_ssl_sources})
158:    ADD_LIBRARY(hiredis::hiredis_ssl ALIAS hiredis_ssl)
161:        SET_PROPERTY(TARGET hiredis_ssl PROPERTY LINK_FLAGS "-Wl,-undefined -Wl,dynamic_lookup")
164:    SET_TARGET_PROPERTIES(hiredis_ssl
169:        SET_TARGET_PROPERTIES(hiredis_ssl
172:    TARGET_LINK_LIBRARIES(hiredis_ssl PRIVATE OpenSSL::SSL)
174:        TARGET_LINK_LIBRARIES(hiredis_ssl PRIVATE hiredis)
176:    CONFIGURE_FILE(hiredis_ssl.pc.in hiredis_ssl.pc @ONLY)
178:    INSTALL(TARGETS hiredis_ssl
179:        EXPORT hiredis_ssl-targets
185:        INSTALL(FILES $<TARGET_PDB_FILE:hiredis_ssl>
190:    INSTALL(FILES hiredis_ssl.h
191:        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/hiredis)
193:    INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/hiredis_ssl.pc
196:    export(EXPORT hiredis_ssl-targets
197:           FILE "${CMAKE_CURRENT_BINARY_DIR}/hiredis_ssl-targets.cmake"
198:           NAMESPACE hiredis::)
201:        SET(CMAKE_CONF_INSTALL_DIR share/hiredis_ssl)
203:        SET(CMAKE_CONF_INSTALL_DIR ${CMAKE_INSTALL_LIBDIR}/cmake/hiredis_ssl)
205:    configure_package_config_file(hiredis_ssl-config.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/hiredis_ssl-config.cmake
209:    INSTALL(EXPORT hiredis_ssl-targets
210:        FILE hiredis_ssl-targets.cmake
211:        NAMESPACE hiredis::
214:    INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/hiredis_ssl-config.cmake
220:    ADD_EXECUTABLE(hiredis-test test.c)
221:    TARGET_LINK_LIBRARIES(hiredis-test hiredis)
224:        TARGET_LINK_LIBRARIES(hiredis-test hiredis_ssl)
228:        TARGET_LINK_LIBRARIES(hiredis-test event)
230:    ADD_TEST(NAME hiredis-test

src/redismodule.h
22: * #include "redismodule.h"

src/crcspeed.c
25:  including commercial applications, and to alter it and redistribute it

README.md
90:This will clean: jemalloc, lua, hiredis, linenoise and other dependencies.
271:_Note_: For compatibility with Redis, we create symlinks from the Redis names (`redis-server`, `redis-cli`, etc.) to the Valkey binaries installed by `make install`.

tests/helpers/fake_redis_node.tcl
3:# Usage: tclsh fake_redis_node.tcl PORT COMMAND REPLY [ COMMAND REPLY [ ... ] ]

tests/unit/info.tcl
143:            catch {r eval {redis.pcall('XGROUP', 'CREATECONSUMER', 's1', 'mygroup', 'consumer') return } 0} e

tests/unit/functions.tcl
148:        r function load REPLACE [get_function_code lua test test {return redis.call('set', 'x', '1')}]
212:        r function load REPLACE [get_no_writes_function_code lua test test {return redis.call('set', 'x', '1')}]
218:        r function load REPLACE [get_no_writes_function_code lua test test {return redis.call('get', 'x')}]
224:        r function load REPLACE [get_function_code lua test test {return redis.call('set', KEYS[1], ARGV[1])}]
419:            r function load REPLACE [get_function_code LUA test test {return redis.call('set', 'x', '1')}]
470:                return redis.call('ping')
627:    test {LIBRARIES - redis.call from function load} {
630:                return redis.call('ping')
636:    test {LIBRARIES - redis.setresp from function load} {
639:                return redis.setresp(3)
645:    test {LIBRARIES - redis.set_repl from function load} {
648:                return redis.set_repl(redis.REPL_NONE)
654:    test {LIBRARIES - redis.acl_check_cmd from function load} {
657:                return redis.acl_check_cmd('set','xx',1)
665:        # function context and the 'redis' API is not
673:            local lib = redis
675:                lib.redis = redis
682:                    lib.redis = redis
692:            redis.math.random()
697:            redis.redis.call('ping')
699:        assert_match {*Script attempted to access nonexistent global variable 'redis'*} $e
992:                callback=function() return redis.call('set', 'x', '1') end,
1044:                callback = function() return redis.call('set', 'x', 1) end
1055:                callback = function() return redis.call('set', 'x', 1) end,
1065:            server.register_function('f1', function() return redis.call('set', 'x', '1') end) 
1093:            server.register_function{function_name='f3', callback=function() return redis.call('get', 'x') end, flags={'allow-stale', 'no-writes'}}
1094:            server.register_function{function_name='f4', callback=function() return redis.call('info', 'server') end, flags={'allow-stale', 'no-writes'}}
1108:        assert_match {*redis_version*} [r fcall f4 0]
1117:            local version = redis.REDIS_VERSION_NUM
1125:            server.register_function{function_name='get_version_v2', callback=function() return redis.REDIS_VERSION end}
1220:                original_globals['redis'] = function() return 1 end

tests/unit/multi.tcl
757:        r script load {redis.call('set', KEYS[1], 'foo')}
774:        r eval {redis.call('set', KEYS[1], 'bar')} 1 bar

tests/unit/introspection.tcl
426:        r eval {redis.call('set',KEYS[1],ARGV[1])} 1 foo bar
434:            server.register_function('test', function() return redis.call('set', 'foo', 'bar') end)
610:        r CLIENT SETINFO lib-name redis.py
613:    } {*lib-name=redis.py lib-ver=1.2.3*}
618:        assert_error {*newlines*} {r CLIENT SETINFO lib-name "redis.py\n"}
622:    } {*lib-name=redis.py lib-ver=1.2.3*}
627:    } {*lib-name=redis.py*} {needs:reset}

tests/unit/expire.tcl
483:        # See Redis OSS issue: https://github.com/redis/redis/issues/8433

tests/unit/client-eviction.tcl
220:        $redirected_c SUBSCRIBE __redis__:invalidate
226:        set script_sha [$rr script load "redis.call('incr', '$long_key')"]

tests/unit/slowlog.tcl
255:                r function load replace "#!lua name=mylib \n redis.register_function('myfunc', function(KEYS, ARGS) server.call('ping') end)"

tests/unit/other.tcl
369:            assert_error "ERR Unknown*" {r config set extended-redis-compatibility yes}
374:            r config set extended-redis-compatibility yes
378:            r config set extended-redis-compatibility no
381:            r config set extended-redis-compatibility yes
383:            assert_equal "redis" [dict get $hello server]
386:            assert_match "*redis_mode:*" $info
388:            r config set extended-redis-compatibility no
393:            assert_no_match "*redis_mode:*" $info

tests/unit/tracking.tcl
8:    $rd_redirection subscribe __redis__:invalidate
31:            $rd_redirection subscribe __redis__:invalidate
203:        $rd_sg eval "return redis.call('set', 'key1', '2')" 1 key1
214:        r EVAL "redis.call('set', 'key3{t}', 'bar')" 2 key1{t} key2{t} 
219:        r EVAL "redis.call('get', 'key2{t}')" 2 key1{t} key2{t}
227:        r EVAL_RO "redis.call('ping')" 2 key1{t} key2{t}
232:        r EVAL_RO "redis.call('get', 'key2{t}')" 2 key1{t} key2{t}
252:        $rd_redirection SUBSCRIBE __redis__:invalidate
349:        $rd_redirection UNSUBSCRIBE __redis__:invalidate ; # Need to unsub first before we can do HELLO 3
351:        assert_equal {__redis__:invalidate} [lindex $res 1]
355:        $rd_redirection SUBSCRIBE __redis__:invalidate
357:        assert_equal {__redis__:invalidate} [lindex $res 1]

tests/unit/pause.tcl
179:            return redis.call('GeT', 'x')..' unique script'
249:            r EVAL_RO "return redis.call('publish','ch','msg')" 0
253:                return redis.call('publish','ch','msg')
257:        assert_equal [r EVAL "return redis.call('publish','ch','msg')" 0] 0

tests/unit/type/zset.tcl
1710:                set fromredis [r zrange myzset 0 -1]
1712:                for {set i 0} {$i < [llength $fromredis]} {incr i} {
1713:                    if {[lindex $fromredis $i] != [lindex $auxlist $i]} {

tests/unit/acl.tcl
777:        catch {r EVAL {redis.call('incr','foo')} 0}

tests/unit/info-command.tcl
4:        regexp {redis_version:(.*?)\r\n} $i - version
5:        regexp {redis_git_sha1:(.*?)\r\n} $i - sha1
17:            assert { [string match "*redis_version*" $info] }

tests/unit/geo.tcl
267:        catch {r geosearch nyc fromlonlat -73.9798091 40.7598464 bybox 6 6 km asc storedist} e
491:        r georadiusbymember points{t} Catania 500 km storedist points2{t}
508:        r georadius points{t} 13.361389 38.115556 500 km storedist points2{t}
516:        r geosearchstore points2{t} points{t} fromlonlat 13.361389 38.115556 byradius 500 km storedist
527:        r georadius points{t} 13.361389 38.115556 500 km storedist points2{t} asc count 1
532:        r georadius points{t} 13.361389 38.115556 500 km storedist points2{t} desc count 1

tests/unit/latency-monitor.tcl
153:                redis.call('sadd',KEYS[1],i)

tests/unit/introspection-2.tcl
38:        r eval {redis.call('touch', KEYS[1])} 1 script_foo
124:            redis.call('set', KEYS[1], 0)
125:            redis.call('expire', KEYS[1], 0)
126:            redis.call('geoadd', KEYS[1], 0, 0, "bar")

tests/unit/sort.tcl
182:            return {redis.call('sort',KEYS[1],'by','nosort','asc'),
183:                    redis.call('sort',KEYS[1],'by','nosort','desc')}

tests/unit/cluster/slot-stats.tcl
278:            redis.call('set', '%s', 'bar'); redis.call('get', '%s')" $key $key] 0
295:            redis.call('set', '%s', 'bar'); redis.call('get', '%s');
309:                callback=function() redis.call('set', '%s', '1') redis.call('get', '%s') end
331:                callback=function() redis.call('set', '%s', '1') redis.call('get', '%s') end,

tests/unit/moduleapi/keyspace_events.tcl
61:                redis.pcall('keyspace.del_key_copy', KEYS[1])
62:                redis.pcall('keyspace.incr_case1', KEYS[1])
63:                redis.pcall('keyspace.incr_case2', KEYS[1])
64:                redis.pcall('keyspace.incr_case3', KEYS[1])

tests/unit/moduleapi/cmdintrospection.tcl
15:        set redis_reply [lindex [r command info xadd] 0]
17:        for {set i 1} {$i < [llength $redis_reply]} {incr i} {
29:            assert_equal [lindex $redis_reply $i] [lindex $module_reply $i]
34:        set redis_reply [dict create {*}[lindex [r command docs xadd] 1]]
37:        dict unset redis_reply group
41:            dict unset redis_reply reply_schema
44:        assert_equal $redis_reply $module_reply

tests/unit/moduleapi/infotest.tcl
30:        catch { [r info.gets badname redis_version] } e

tests/unit/moduleapi/propagate.tcl
449:                        redis.call("propagate-test.simple"); \
450:                        redis.call("set", "x", "y"); \
451:                        redis.call("propagate-test.mixed"); return "OK" } 0 ] {OK}
734:            r EVAL {return redis.call('SET', KEYS[1], ARGV[1])} 1 foo bar2
736:            r EVAL {return redis.call('test.rm_call_replicate',ARGV[1],KEYS[1],ARGV[2])} 1 foo set bar4
740:            r EVAL {return redis.call('SET', KEYS[1], ARGV[1])} 1 foo bar6
742:            r EVAL {return redis.call('test.rm_call_replicate',ARGV[1],KEYS[1],ARGV[2])} 1 foo set bar8

tests/unit/moduleapi/usercall.tcl
4:redis.call('set','x',1)
8:redis.call('get','x')

tests/unit/cluster/scripting.tcl
7:                redis.call('set', 'foo', 'bar')
8:                redis.call('set', 'bar', 'foo')
15:                redis.call('set', 'foo', 'bar')
16:                redis.call('set', 'bar', 'foo')
26:        r 0 eval "redis.call('set', 'foo', 'bar'); redis.call('set', 'bar', 'foo')" 0
30:            redis.call('set', 'foo', 'bar'); redis.call('set', 'bar', 'foo')
43:                redis.call('set', 'foo', 'bar')
44:                redis.call('set', 'bar', 'foo')
60:                redis.call('set', 'foo', 'bar')
67:        r 0 eval "redis.call('set', 'foo', 'bar')" 1 bar
93:        assert_equal [lsort [r 0 cluster slots]] [lsort [r 0 eval "return redis.call('cluster', 'slots')" 0]]
97:        assert_equal [lsort [r 0 cluster shards]] [lsort [r 0 eval "return redis.call('cluster', 'shards')" 0]]

tests/unit/moduleapi/commandfilter.tcl
41:    test {Command Filter applies on Lua redis.call()} {
43:        r eval "redis.call('ping', '@log')" 0
47:    test {Command Filter applies on Lua redis.call() that calls a module} {
49:        r eval "redis.call('commandfilter.ping')" 0
91:        r eval "redis.call('commandfilter.ping')" 0
110:        r eval {redis.call('rpush', KEYS[1], 'elem1', 'elem2', 'elem3', 'elem4')} 1 mylist
112:        r eval {redis.call('rpush', KEYS[1], '@insertafter')} 1 mylist
114:        r eval {redis.call('rpush', KEYS[1], 'elem1', 'elem2', 'elem3', 'elem4')} 1 mylist

tests/cluster/tests/04-resharding.tcl
113:            $cluster eval {redis.call("rpush",KEYS[1],ARGV[1])} 1 $key $ele

tests/unit/moduleapi/misc.tcl
143:        $rd_trk test.rm_call EVAL "redis.call('get', 'key1{t}')" 2 key1{t} key2{t}
250:                redis.call('set','x',1)
258:                redis.call('set','x',1)
278:            redis.call('set','x',1)
284:                redis.call('set','x',1)
297:                redis.call('set','x',1)
304:            redis.call('set','x', 1)
310:            redis.call('get','x')
317:                redis.call('get','x')
324:            redis.call('get','x')
337:            redis.call('set','x',1)
343:            redis.call('set','x', 1)
349:            redis.call('set','x', 1)
365:                return redis.call('get','x')
371:                return redis.call('get','x')
377:                return redis.call('get','x')
383:                return redis.call('set','x', 1)
398:                redis.call('set','x',1)
404:            redis.call('get','x')
410:                redis.call('get','x')
416:            redis.call('get','x')
434:                redis.call('get','x')
441:                redis.call('get','x')
470:            return redis.call('set','x',1)
474:            return redis.call('get','x')
480:            return redis.call('set','x',1)
484:            return redis.call('get','x')

tests/unit/pubsub.tcl
494:                redis.call("ping","abc")
495:                redis.call("publish","foo","bar")
496:                redis.call("publish","foo","vaz")
497:                redis.call("ping","def")
508:        # breaks the multi response, see Redis OSS issue: https://github.com/redis/redis/issues/12207

utils/redis-sha1.rb
1:# redis-sha1.rb - Copyright (C) 2009 Redis Ltd.
12:require 'redis'
15:def redisSha1(opts={})
52:p "Dataset SHA1: #{redisSha1(:host => host, :port => port.to_i, :db => db)}"

tests/unit/commandlog.tcl
327:                r function load replace "#!lua name=mylib \n redis.register_function('myfunc', function(KEYS, ARGS) server.call('ping') end)"

tests/modules/keyspace_events.c
5: * Copyright (c) 2020, Meir Shpilraien <meir at redislabs dot com>

tests/modules/postnotifications.c
5: * Copyright (c) 2020, Meir Shpilraien <meir at redislabs dot com>

tests/modules/propagate.c
162:    reply = ValkeyModule_Call(ctx, "EVAL", "cccc!", "redis.call('set',KEYS[1],ARGV[1])", "1", "foo", "bar");

tests/rdma/rdma-test.c
689:    /* it's time to tell redis we have already connected */

tests/unit/scripting.tcl
2:foreach script_compatibility_api {server redis} {
4:# We run the tests using both the server APIs, e.g. server.call(), and valkey APIs, e.g. redis.call(),
7:    proc replace_script_redis_api_with_server {args} {
8:        set new_string [regsub -all {redis\.} [lindex $args 0] {server.}]
16:    proc replace_script_redis_api_with_server {args} {
21:        return "redis"
27:        set args [replace_script_redis_api_with_server $args]
31:        set args [replace_script_redis_api_with_server $args]
35:        set args [replace_script_redis_api_with_server $args]
43:        set args [replace_script_redis_api_with_server $args]
52:        set args [replace_script_redis_api_with_server $args]
61:        set args [replace_script_redis_api_with_server $args]
75:    if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
79:        catch {[r eval "redis.call('set', 'x', 1)" 0]} e
99:        run_script {local a = {}; setmetatable(a,{__index=function() redis.call('set', 'x', '1') end}) return a} 1 x
141:        run_script {return redis.call('get',KEYS[1])} 1 mykey
144:    if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
172:            local foo = redis.pcall('incr',KEYS[1])
180:            local foo = redis.pcall('hincrby','hash','field',200000000)
188:            local foo = redis.pcall('get',KEYS[1])
199:            local foo = redis.pcall('lrange',KEYS[1],0,-1)
206:            local foo = redis.pcall('set',KEYS[1],'myval')
214:            local foo = redis.pcall('incr',KEYS[1])
222:            local foo = redis.pcall('get',KEYS[1])
231:        run_script {return redis.pcall('get',KEYS[1])} 1 mykey
237:        run_script {return redis.pcall('select','9')} 0
259:        run_script {return redis.pcall('blpop','l',0)} 1 l
265:        run_script {return redis.pcall('brpop','l',0)} 1 l
271:        run_script {return redis.pcall('brpoplpush','empty_list1{t}', 'empty_list2{t}',0)} 2 empty_list1{t} empty_list2{t}
277:        run_script {return redis.pcall('blmove','empty_list1{t}', 'empty_list2{t}', 'LEFT', 'LEFT', 0)} 2 empty_list1{t} empty_list2{t}
283:        run_script {return redis.pcall('bzpopmin','empty_zset', 0)} 1 empty_zset
289:        run_script {return redis.pcall('bzpopmax','empty_zset', 0)} 1 empty_zset
293:        run_script {return redis.pcall('wait','1','0')} 0
297:        run_script {return redis.pcall('waitaof','0','1','0')} 0
303:        set res [run_script {return redis.pcall('xread','STREAMS','s','$')} 1 s]
305:        run_script {return redis.pcall('xread','BLOCK',0,'STREAMS','s','$')} 1 s
309:        set res [run_script {return redis.pcall('xreadgroup','group','g','c','STREAMS','s','>')} 1 s]
311:        run_script {return redis.pcall('xreadgroup','group','g','c','BLOCK',0,'STREAMS','s','>')} 1 s
316:        set res [run_script {return redis.pcall('xread','BLOCK',0,'STREAMS','s','$')} 1 s]
319:        set res [run_script {return redis.pcall('xread','BLOCK',0,'STREAMS','s','0-0')} 1 s]
326:            run_script {return redis.pcall('xreadgroup','group','g','c','BLOCK',0,'STREAMS','s','>')} 1 s
335:            run_script {redis.pcall('randomkey'); return redis.pcall('set','x','ciao')} 1 x
340:    test {EVAL - No arguments to redis.call/pcall is considered an error} {
342:        catch {run_script {return redis.call()} 0} e
346:    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {
349:            run_script "redis.call('nosuchcommand')" 0
354:    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {
357:            run_script "redis.call('get','a','b','c')" 0
362:    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {
366:            run_script {redis.call('lpush',KEYS[1],'val')} 1 foo
594:        assert_equal bar [run_script_ro {return redis.call('get', KEYS[1]);} 1 foo]
599:        catch {run_script_ro {redis.call('del', KEYS[1]);} 1 foo} e
603:    if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
608:        r script load {return redis.call('get',KEYS[1])}
614:        r eval {return redis.call('get',KEYS[1])} 1 mykey
659:        r eval {return redis.call('sort',KEYS[1],'desc')} 1 myset
665:        r eval {return redis.call('sort',KEYS[1],'by','_')} 1 myset
671:        r eval {return redis.call('sort',KEYS[1],'by','_','get','#','get','_:*')} 1 myset
675:    test "redis.sha1hex() implementation" {
676:        list [run_script {return redis.sha1hex('')} 0] \
677:             [run_script {return redis.sha1hex('Pizza & Mandolino')} 0]
746:            current = redis.call('get',KEYS[1])
749:                return redis.call('decr',KEYS[1])
751:                return redis.call('get',KEYS[1])
764:    if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
796:            run_script_on_connection $rd {return redis.call("incr",KEYS[1])} 1 x
806:    if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
813:        assert {[r eval {return redis.call('spop', 'myset')} 0] ne {}}
814:        assert {[r eval {return redis.call('spop', 'myset', 1)} 0] ne {}}
815:        assert {[r eval {return redis.call('spop', KEYS[1])} 1 myset] ne {}}
817:        assert {[r eval {return redis.call('spop', KEYS[1])} 1 myset] eq {}}
836:        assert {[r eval {return redis.call('mget', 'a{t}', 'b{t}', 'c{t}', 'd{t}')} 0] eq {1 2 3 4}}
850:        assert {[r eval {return redis.call('expire', KEYS[1], ARGV[1])} 1 expirekey 3] eq 1}
869:            r eval {redis.call('hmget', KEYS[1], 1, 2, 3)} 1 key
871:            r eval {redis.call('incrbyfloat', KEYS[1], 1)} 1 key
873:            r eval {redis.call('set', KEYS[1], '1', 'KEEPTTL')} 1 key
890:            redis.call('del','mylist')
894:            redis.call('rpush','mylist',unpack(x))
895:            return redis.call('lrange','mylist',0,-1)
902:              redis.call("set","foo",value)
903:              return redis.call("get","foo")
909:            redis.call("set", "key", "12039611435714932082")
910:            return redis.call("get", "key")
920:        assert_error "ERR Wrong number of args calling command from script*" {run_script "redis.call('set','invalid')" 0}
921:        assert_error "ERR Wrong number of args calling command from script*" {run_script "redis.call('incr')" 0}
927:                  redis.call('SET', 'a{t}', '1')
928:                  redis.call('MGET', 'a{t}', 'b{t}', 'c{t}')
929:                  redis.call('EXPIRE', 'a{t}', 0)
930:                  redis.call('GET', 'a{t}')
931:                  redis.call('MGET', 'a{t}', 'b{t}', 'c{t}')
939:                  redis.sha1hex()
948:                  redis.call('cluster', 'reset', 'hard')
965:        set res [run_script {redis.setresp(3); return redis.call('hgetall', KEYS[1])} 1 hash]
967:        set res [run_script {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]
972:        set res [run_script {redis.setresp(3); return redis.call('hgetall', KEYS[1])} 1 hash]
974:        set res [run_script {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]
1002:            return redis.call("lpush", "l", unpack(a))
1009:             if redis.call("EXISTS", "key") then
1010:                 return redis.call("GET", "key")
1012:                 return redis.call("EXISTS", "key")
1020:             redis.call("DEL", "key")
1021:             return redis.call("EXISTS", "key")
1031:            return redis.acl_check_cmd('set','xx',1)
1036:            return redis.acl_check_cmd('hset','xx','f',1)
1042:            return redis.acl_check_cmd('set','yy',1)
1047:            return redis.acl_check_cmd('invalid-cmd','arg')
1079:                redis = function() return 1 end
1097:                redis.call = function() return 1 end
1177:        run_script_on_connection $rd {local f = function() while 1 do redis.call('ping') end end while 1 do pcall(f) end} 0
1207:        # 1. eval "while 1 do redis.call('ping') end" 0
1210:            set buf "*3\r\n\$4\r\neval\r\n\$33\r\nwhile 1 do redis.call('ping') end\r\n\$1\r\n0\r\n"
1252:        run_script {for i=1,100000 do redis.call('ping') end return 'ok'} 0
1275:            redis.call('lpush',KEYS[1],'y');
1277:                clients = redis.call('client','list')
1280:            redis.call('lpush',KEYS[1],'z');
1307:        run_script_on_connection $rd {redis.call('set',KEYS[1],'y'); while true do end} 1 x
1336:                    run_script {redis.call('incr',KEYS[1]); redis.call('nonexisting')} 1 x
1340:                run_script {return redis.call('incr',KEYS[1])} 1 x
1353:            if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
1376:                    redis.call("lpush",KEYS[1],"1");
1377:                    redis.call("lpush",KEYS[1],"2");
1389:            if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
1392:                r eval {if tonumber(ARGV[1]) > 0 then redis.call('incr', KEYS[1]) end} 1 x 0
1405:                    redis.call("set","foo1","bar1")
1406:                    redis.call("select","10")
1407:                    redis.call("incr","x")
1408:                    redis.call("select","11")
1409:                    redis.call("incr","z")
1412:                    redis.call("set","foo1","bar1")
1413:                    redis.call("select","10")
1414:                    redis.call("incr","x")
1415:                    redis.call("select","11")
1416:                    redis.call("incr","z")
1442:                redis.call('set','foo','bar');
1443:                return redis.replicate_commands();
1450:                    redis.set_repl(redis.REPL_ALL);
1459:                    redis.set_repl(12345);
1468:                redis.call('set','a','1');
1469:                redis.set_repl(redis.REPL_NONE);
1470:                redis.call('set','b','2');
1471:                redis.set_repl(redis.REPL_AOF);
1472:                redis.call('set','c','3');
1473:                redis.set_repl(redis.REPL_ALL);
1474:                redis.call('set','d','4');
1493:            if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
1494:                # on is_eval Lua we need to call redis.replicate_commands() to get real randomization
1497:                        redis.replicate_commands()
1503:                        redis.replicate_commands()
1524:                redis.call('set','time',redis.call('time')[1])
1538:if {$is_eval eq 1 && $script_compatibility_api == "redis"} {
1562:        set cmd "*101\r\n\$5\r\nredis\r\n"
1702:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'bignum')" 0]
1724:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'map')" 0]
1737:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'set')" 0]
1750:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'double')" 0]
1761:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'null')" 0]
1771:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'verbatim')" 0]
1785:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'true')" 0]
1795:                set ret [run_script "redis.setresp($i);return redis.call('debug', 'protocol', 'false')" 0]
1813:        run_script "redis.setresp(3);return redis.call('debug', 'protocol', 'attrib')" 0
1818:            redis.call("SET", "key", "value", "PX", "1")
1819:            redis.call("DEBUG", "SLEEP", 0.01)
1820:            return redis.call("EXISTS", "key")
1834:        assert_equal [run_script {return redis.call('EXISTS', 'key')} 1 key] 0
1841:            local result1 = {redis.call("TIME")}
1842:            redis.call("DEBUG", "SLEEP", 0.01)
1843:            local result2 = {redis.call("TIME")}
1854:            redis.call("SET", "key1{t}", "value", "EX", 1)
1855:            redis.call("DEBUG", "SLEEP", 0.01)
1857:            redis.call("SET", "key2{t}", "value", "PX", 1000)
1858:            redis.call("DEBUG", "SLEEP", 0.01)
1860:            redis.call("SET", "key3{t}", "value")
1861:            redis.call("EXPIRE", "key3{t}", 1)
1862:            redis.call("DEBUG", "SLEEP", 0.01)
1864:            redis.call("SET", "key4{t}", "value")
1865:            redis.call("PEXPIRE", "key4{t}", 1000)
1866:            redis.call("DEBUG", "SLEEP", 0.01)
1868:            redis.call("SETEX", "key5{t}", 1, "value")
1869:            redis.call("DEBUG", "SLEEP", 0.01)
1871:            redis.call("PSETEX", "key6{t}", 1000, "value")
1872:            redis.call("DEBUG", "SLEEP", 0.01)
1874:            redis.call("SET", "key7{t}", "value")
1875:            redis.call("GETEX", "key7{t}", "EX", 1)
1876:            redis.call("DEBUG", "SLEEP", 0.01)
1878:            redis.call("SET", "key8{t}", "value")
1879:            redis.call("GETEX", "key8{t}", "PX", 1000)
1880:            redis.call("DEBUG", "SLEEP", 0.01)
1882:            local ttl_results = {redis.call("TTL", "key1{t}"),
1883:                                 redis.call("TTL", "key2{t}"),
1884:                                 redis.call("TTL", "key3{t}"),
1885:                                 redis.call("TTL", "key4{t}"),
1886:                                 redis.call("TTL", "key5{t}"),
1887:                                 redis.call("TTL", "key6{t}"),
1888:                                 redis.call("TTL", "key7{t}"),
1889:                                 redis.call("TTL", "key8{t}")}
1891:            local pttl_results = {redis.call("PTTL", "key1{t}"),
1892:                                  redis.call("PTTL", "key2{t}"),
1893:                                  redis.call("PTTL", "key3{t}"),
1894:                                  redis.call("PTTL", "key4{t}"),
1895:                                  redis.call("PTTL", "key5{t}"),
1896:                                  redis.call("PTTL", "key6{t}"),
1897:                                  redis.call("PTTL", "key7{t}"),
1898:                                  redis.call("PTTL", "key8{t}")}
1900:            local expiretime_results = {redis.call("EXPIRETIME", "key1{t}"),
1901:                                        redis.call("EXPIRETIME", "key2{t}"),
1902:                                        redis.call("EXPIRETIME", "key3{t}"),
1903:                                        redis.call("EXPIRETIME", "key4{t}"),
1904:                                        redis.call("EXPIRETIME", "key5{t}"),
1905:                                        redis.call("EXPIRETIME", "key6{t}"),
1906:                                        redis.call("EXPIRETIME", "key7{t}"),
1907:                                        redis.call("EXPIRETIME", "key8{t}")}
1909:            local pexpiretime_results = {redis.call("PEXPIRETIME", "key1{t}"),
1910:                                         redis.call("PEXPIRETIME", "key2{t}"),
1911:                                         redis.call("PEXPIRETIME", "key3{t}"),
1912:                                         redis.call("PEXPIRETIME", "key4{t}"),
1913:                                         redis.call("PEXPIRETIME", "key5{t}"),
1914:                                         redis.call("PEXPIRETIME", "key6{t}"),
1915:                                         redis.call("PEXPIRETIME", "key7{t}"),
1916:                                         redis.call("PEXPIRETIME", "key8{t}")}
1936:            redis.call("SET", "key1{t}", "value")
1937:            local encoded = redis.call("DUMP", "key1{t}")
1939:            redis.call("RESTORE", "key2{t}", 1, encoded, "REPLACE")
1940:            redis.call("DEBUG", "SLEEP", 0.01)
1941:            redis.call("RESTORE", "key3{t}", 1, encoded, "REPLACE")
1943:            return {redis.call("PEXPIRETIME", "key2{t}"), redis.call("PEXPIRETIME", "key3{t}")}
1998:                redis.call('set','x',1)
2005:                return redis.call('get','x')
2019:                redis.call('set','x',1)
2027:                redis.call('get','x')
2033:                redis.call('get','x')
2041:                redis.call('get','x')
2049:                redis.call('get','x')
2060:                redis.call('set','x',1)
2079:                    return redis.call('get','x')
2085:                    return redis.call('get','x')
2092:                redis.call('get','x')
2100:                redis.call('get','x')
2121:                redis.call('set','x',1)
2139:                return redis.call('get','x')
2145:                return redis.call('get','x')
2151:                return redis.call('get','x')
2157:                return redis.call('set','x', 1)
2177:                redis.call('set','x',"script value")
2179:                    local info = redis.call('info','replication')
2181:                        redis.call('set','x',info)
2216:                return redis.call('get','x')
2235:                return redis.call('get','x')
2241:                return redis.call('echo','foobar')
2248:                return redis.call('echo','foobar')
2279:            r eval {return redis.call('set','x','y')} 1 x
2286:        # redis.pcall() failure due to server state (OOM) returns lua error table with server error message without '-' prefix
2290:                local t = redis.pcall('set','x','y')
2308:            r eval { return redis.pcall('set','x','y') } 1 x
2320:            r eval {return redis.call('select',99)} 0
2327:        # redis.pcall() failure due to error in server command returns lua error table with server error message without '-' prefix
2331:                local t = redis.pcall('select',99)
2347:            r eval_ro {return redis.call('set','x','y')} 1 x
2354:        # redis.pcall() failure due to scripting specific error state (write cmd with eval_ro) returns lua error table with server error message without '-' prefix
2358:                local t = redis.pcall('set','x','y')
2375:            r eval {return redis.call('GEOADD', 'Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania')} 1 x
2383:    test "LUA redis.error_reply API" {
2386:            r eval {return redis.error_reply("MY_ERR_CODE custom msg")} 0
2391:    test "LUA redis.error_reply API with empty string" {
2394:            r eval {return redis.error_reply("")} 0
2399:    test "LUA redis.status_reply API" {
2403:            r eval {return redis.status_reply("MY_OK_CODE custom msg")} 0
2425:                return redis.call("ping", x)
2431:                return redis.call("ping", "asdf")
2448:                return redis.call("SETNX", "foo", string.rep("a", 63))
2454:                return redis.call("SET", "foo", string.rep("a", 45))

tests/support/valkey.tcl
275:proc ::valkey::redis_multi_bulk_read {id fd} {
362:            * {return [redis_multi_bulk_read $id $fd]}

tests/support/cluster.tcl
1:# Tcl cluster client as a wrapper of redis.rb.

utils/redis-copy.rb
1:# redis-copy.rb - Copyright (C) 2009-2010 Redis Ltd.
7:#          for the more-robust redis-copy gem.
11:def redisCopy(opts={})
14:  `redis-copy #{src.shellescape} #{dst.shellescape}`
16:  $stderr.puts 'This utility requires the redis-copy executable',
17:               'from the redis-copy gem on https://rubygems.org',
18:               'To install it, run `gem install redis-copy`.'
22:$stderr.puts "This utility is deprecated. Use the redis-copy gem instead."
24:    puts "Usage: redis-copy.rb <srchost> <srcport> <dsthost> <dstport>"
34:redisCopy(:srchost => srchost, :srcport => srcport.to_i,

utils/speed-regression.tcl
36:        set r [redis 127.0.0.1 $::port]
105:set is_not_running [catch {set r [redis 127.0.0.1 $::port]}]

tests/sentinel/tests/13-info-command.tcl
11:        assert { [string match "*redis_version*" $info] }
26:    assert { ![string match "*redis_version*" $info] }
31:    assert { ![string match "*redis_version*" $info] }
36:    assert { [string match "*redis_version*" $info] }
44:    assert { [string match "*redis_version*" $info] }

tests/sentinel/tests/includes/init-tests.tcl
14:set redis_slaves [expr $::instances_count - 1]
15:test "(init) Create a primary-replicas cluster of [expr $redis_slaves+1] instances" {
16:    create_valkey_master_slave_cluster [expr {$redis_slaves+1}]
58:            [dict get [S $id SENTINEL PRIMARY mymaster] num-slaves] == $redis_slaves

tests/sentinel/tests/08-hostname-conf.tcl
3:proc set_redis_announce_ip {addr} {
28:    set_redis_announce_ip $::host
66:    set_redis_announce_ip $::host

tests/integration/aof.tcl
439:                append_to_aof [formatCommand eval {redis.call('set',KEYS[1],'y'); for i=1,1500000 do redis.call('ping') end return 'ok'} 1 x]
463:            append_to_aof [formatCommand eval {redis.call("set",KEYS[1],"100")} 1 foo]
464:            append_to_aof [formatCommand eval {redis.call("incr",KEYS[1])} 1 foo]
465:            append_to_aof [formatCommand eval {redis.call("incr",KEYS[1])} 1 foo]

tests/integration/valkey-cli.tcl
362:if {!$::tls} { ;# fake_redis_node doesn't support TLS
366:        set script "tests/helpers/fake_redis_node.tcl"
836:    test "Valid Connection Scheme: redis://" {
837:        set cmdline [valkeycliuri "redis://" [srv host] [srv port]]
847:        test "Valid Connection Scheme: rediss://" {
848:            set cmdline [valkeycliuri "rediss://" [srv host] [srv port]]

utils/srandmember/README.md
4:See http://theshfl.com/redis_sets for more information on the topic that lead

utils/srandmember/showfreq.rb
1:require 'redis'

utils/srandmember/showdist.rb
1:require 'redis'

utils/hyperloglog/hll-gnuplot-graph.rb
9:require 'redis'

utils/req-res-validator/requirements.txt
2:redis==4.5.1

utils/hyperloglog/hll-err.rb
7:require 'redis'

tests/integration/replication.tcl
281:            r -1 eval {redis.call("flushdb")} 0
286:            r -1 eval {redis.call("flushall")} 0

tests/integration/rdb.tcl
445:    # the script is: "return redis.call('set', 'foo', 'bar')""
473:            return redis.call('set','x',1)
477:            return redis.call('get','x')
483:            return redis.call('set','x',1)
487:            return redis.call('get','x')

tests/integration/cross-version-replication.tcl
8:        set server_name redis

tests/integration/replication-4.tcl
64:            server.register_function{function_name='f_default_flags', callback=function(keys, args) return redis.call('get',keys[1]) end, flags={}}
65:            server.register_function{function_name='f_no_writes', callback=function(keys, args) return redis.call('get',keys[1]) end, flags={'no-writes'}}
77:            assert_equal OK [$master eval "return redis.call('set','foo',12345)" 0]
84:            assert_error "*NOREPLICAS*" {$master eval "redis.call('set','foo','bar')" 0}
95:            $master eval "redis.call('set','foo','bar')" 0
98:            $master eval "return redis.call('get','foo')" 0
105:            assert_equal OK [$master eval "return redis.call('set','foo',12345)" 0]
115:            assert_error "*NOREPLICAS*" {$master eval "return redis.call('set','foo',12345)" 0}

utils/req-res-log-validator.py
9:import redis
26:1. Goes over req-res files, generated by redis-servers, spawned by the testsuite (see logreqres.c)
31:In order to use this file you must run the redis testsuite with the following flags:
240:    redis_proc = subprocess.Popen(args, stdout=subprocess.PIPE)
245:            r = redis.Redis(port=port)
264:    redis_proc.terminate()
265:    redis_proc.wait()
287:    redis_args = [args.server, '--port', str(args.port)]
289:        redis_args += ['--loadmodule', 'tests/modules/%s.so' % module]
291:    fetch_schemas(args.cli, args.port, redis_args, docs)

utils/build-static-symbols.tcl
1:# Build a symbol table for static symbols of redis.c
2:# Useful to get stack traces on segfault without a debugger. See redis.c
7:set fd [open redis.c]

utils/lru/test-lru.rb
2:require 'redis'

cmake/Modules/ValkeySetup.cmake
64:    # Install cli tool and create a redis symbolic link
86:    target_link_libraries(${target} hiredis)
89:        target_link_libraries(${target} OpenSSL::SSL hiredis_ssl)
99:    # Install cli tool and create a redis symbolic link
117:        target_link_libraries(${target} OpenSSL::SSL hiredis_ssl)
124:    # Install cli tool and create a redis symbolic link
299:include_directories("${CMAKE_SOURCE_DIR}/deps/hiredis")

$ 
